---
title: "Basics"
---

```{css, echo=FALSE}
#.r-chunk {
#  background-color: lightpink;
#}
#
#.py-chunk {
#  background-color: lightblue;
#}
#toc: true
#    number_sections: true
#    theme: flatly
#    highlight: kate
#    toc_float:
#      collapsed: false
#      smooth_scroll: true
#  
#
#author: "Pierre Pelletier"
#date: "3 septembre 2020"
#output:
#  html_document:
#  toc: true
#  toc_float: true
#  toc_collapsed: true
#  toc_depth: 3
#  number_sections: true
#  theme: lumen
#
#toc: true
#    number_sections: true
#    theme: flatly
#    highlight: kate
#    toc_float:
#      collapsed: false
#      smooth_scroll: true
#
#



```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,error=TRUE,collapse = T)
library(reticulate)

#  md_document:
#    variant: markdown_github
#
#
#<div class = "row">
#<div class = "col-md-6">
#<div class = "python">
#  
#
#</div>
#</div>
#<div class = "col-md-6">
#<div class = "r">  
#  
#  
#</div>
#</div>
#</div>


#<style>
#div.blue pre { background-color:lightblue; }
#div.blue pre.r { background-color:blue; }
#</style>
#
```

<style>
div.python pre { background-color: #d0f5a9; }
</style>

<style>
div.r pre { background-color: #dfdddf; }
</style>

This capter introduce the basics of R and Python. The goal of this chapter is to discover the different type of object that we can deal with for each language, to understand the logic of control flows and function writting. Along this chapter we will see what differs between R and Python but also how similar they can be.\nThe chapter ends with 3 Exercices from Euler Project. By forming a group of 2, solve at least one exercice in the language of your choice. try to compare different approach.


<p>&nbsp;</p>

# Operations

## Arithmetic Operations
Python and R work as classical calculator, using "+", "-", "*" and "/" we can do arithmetic operations in both language.

<div class = "row">
<div class = "col-md-6">
<div class = "python">

```{python}
# Python 

1+2
1-2
1/2
1*2

```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r, collapse = TRUE}
# R

1+2
1-2
1/2
1*2
```

</div>
</div>
</div>

<p>&nbsp;</p>

We can also apply exponantiation, Modulo and floor division easily in both language. Note that in R we can writte the exponantiation "^". It is used for exclusive-or (bitwise) in Python.


<div class = "row">
<div class = "col-md-6">
<div class = "python">

```{python,echo = T,collapse = TRUE}
# Python 

2**8 # exponantiation
2^8 == 2**8 # False
8%3 # modulo
8//3 # floor division
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R

2**8 # exponantiation
2^8 == 2**8 # TRUE
8%%3 # modulo
8%/%3 # floor division

```

</div>
</div>
</div>
Operator (R) | Operator (Python) |	Description
-|:-:|-:
+ | + |	Addition
– | – |	Subtraction
* | * |	Multiplication
/ | / |	Division
^ / ** | ** |	Exponent
%% | % |	Modulo
%/% | // |	floor Division


<p>&nbsp;</p>
##  Comparison Operators

In order to compare some values we can use comparison operators to investigate in a given value is equal to, not equal, greater than ... etc

Theses operators are the same in both language.

<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 

2==8
2!=8
2<8
2>8
2<=8

```

</div>
</div>
<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R

2==8
2!=8
2<8
2>8
2<=8
```
</div>
</div>
</div>

Operator (R/Python) |	Description
-|-:
\< 	| Less than
\> 	| Greater than
\<= 	| Less than or equal to
\>= 	| Greater than or equal to
== 	| Equal to
!= 	| Not equal to

<p>&nbsp;</p>

## Logical operators


<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 
x = [True,True]
y = [True,False]

not x[0]
x and y
x or y
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R

x = c(TRUE,TRUE)
y = c(TRUE,FALSE)

!x[1]
x & y
x && y
x | y
x || y
```
</div>
</div>
</div>

Operator (R)| Operator (Python)|	Description
-|:-:|-:
! | not |	Logical NOT
& | and |	Element-wise logical AND
&& |  |Logical AND
\| |or|	Element-wise logical OR
\|\|  | |	Logical OR


<p>&nbsp;</p>
## Membership operators

In and not in are membership operators in Python. They are used to test whether a value or variable is found in a sequence. In R %in% allows you to use the python in, but you have to be aware that they may not react the same way, the reason is that list of character can be directly decomposed in a character list in python, which is not the case in R.
See how we can check that 'Hello' is in 'Hello world' using just in with python. In R we look if the string exactly match one element.


<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 
x = 'Hello world'
y = {1:'a',2:'b'}

print('world' in x)

print(1 in y)

print('a' in y)
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R

x = 'Hello World'

print('Hello' %in% x)
stringr::str_detect(x,'Hello')
```
</div>
</div>
</div>



<p>&nbsp;</p>

<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 
x = ['Hello','World']

print('Hello' in x)
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R

x = c('Hello','World')

print('Hello' %in% x)
```
</div>
</div>
</div>


<p>&nbsp;</p>

# Objects & Variables

ref used : https://www.practicaldatascience.org/html/vars_v_objects.html

Variables are used to store data. In Python and R, we do not need to declare a variable before assigning a value to this variable. we can think of a variable as a name to refers to an object. There is a big difference between python and R on the way the computer is storing object and variables that we will see in the end of the section.


<p>&nbsp;</p>

## Difference between R and Python

https://learnanalyticshere.wordpress.com/2015/05/14/clash-of-the-titans-r-vs-python/

While Python is a lot praised for being a general-purpose language with an easy-to-understand syntax, R's functionality is developed with statisticians in thoughts, thus giving it field-specific advantages such as excessive features for data visualization.


In R, a variable and an object are the same things, they refers to the same entities. If we assign to a new variable a variable that already exist, it will refers to two different objects.

Things in Python are more conventional, but since some people learned R before Python it's important to notice that variables refers to an objet but they are still two entities.
It means that two variables can refer to a single object. If two variables are pointing the same object, the modification made with one variable will be also available when using the other variable.


we mostly should never use for loops in R - they're horribly slow because they execute a function call with every iteration. (One should vectorize and use the apply family of functions instead. Weird, I know..) Vectorization is king in R if we want fast code. Assuming we vectorize both our R and Python code (and other factors), we should probably get the same order of magnitude in speed. For data larger than memory (we can specify the limit), R starts to become a bad choice. 



<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 
import numpy as np
only_nb = [1,2,3,4]
np.std(only_nb)
np.std(only_nb,ddof=1)
with_none = [1,2,3,None]
np.std(with_none)
with_char = [1,2,'3',4]
np.std(with_char)

```

</div>
</div>
<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R
only_nb <- c(1,2,3,4)
sd(only_nb)
with_na <- c(1,2,3,NA)
sd(with_na)
with_char <- c(1,2,'3',4)
sd(with_char)

with_char <- c(1,2,'a',4)
sd(with_char)

```
</div>
</div>

<p>&nbsp;</p>

See how R do not show any error and directly remove NA to compute the standart deviation and also convert string to numeric if possible. If converting the string to numeric is not feasible, R finally return a NA. This is not an error message but a warning message. 

We need to writte our code carefully since R can do calculation for a while and just return NA without stopping the process which is not the case in Python. 

Also see here that R calulates the standard deviation with N - 1 as the denominator, and numpy with N. To get the same result we need to use 'ddof=1' as argument in std.
</div>


<p>&nbsp;</p>
## Textual and numerical variables

In R textual data are called 'character', in Python it is a string, abbreviate as 'str'. " or ' are used when we set a textual variable in both laguage, but we can also set a variable to textual variable if needed.

Numerical variables a decomposed in three types. In Python we'll have integer, float and complex. In R float is called 'double', reffering to double precision floating point. Without entering into details it means that the number have a precision up to 15 decimals. Float can refers to a precision of 7 decimals, however in Python the data-type 'float' has a precision of 15 numbers. They are ways to get more precisions using Numpy for example. 

Finaly we can check easily the data-type of the variable that we are dealing by asking the language with the command 'type' in Python, or 'typeof' in R.

<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 

import sys 
sys.float_info.dig # number of decimals

a = 1
type(a)

b = 1.1
type(b)

c = 1.1+2j
type(c)

d = 'd'
type(d)

# change the type
e = 2
f = str(e)
f
float(f)
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R

a = 1
typeof(a)
a_int = 1L
typeof(a_int)

b = 1.1
typeof(b)

c = 1.1+2i
typeof(c)

d = 'd'
typeof(d)

# change the type
e = 2
f = as.character(e)
f
as.numeric(f)
```
</div>
</div>
</div>

<p>&nbsp;</p>

## Other Data-Type (R)
https://www.statmethods.net/input/datatypes.html

There is a lot of datatype in both language that we will discover along the course, for now we will focus only on basic data-type that are directly available without using anyother package or library,in R common data-type are Vector, Matrix, List, Data frame and factor.

<p>&nbsp;</p>

### Vectors and Matrices

<div class = "r">

<div class = "row">
<div class = "col-md-6">

```{r}
# R

vec = c(1, 2, 3)
length(which(vec==2)) # count elements of the list which are exactly equal to 2

vec = sort(vec,
           decreasing = TRUE)
vec
# access the element of a list
vec[1]
vec[which(vec==3)]
vec[2:length(vec)]
vec[length(vec):2]
vec[-1] # throwaway value


```

</div>
<div class = "col-md-6">

```{r}
# R

mat = matrix(c(1, 2, 3, 4, 5, 6),3,2)
dim(mat)
mat

length(which(mat==2)) # count elements of the list which are exactly equal to 2

vec = sort(mat,
           decreasing = TRUE)
vec
# access the element of a list
mat[1] # first element
which(mat==3,
      arr.ind = TRUE) # get row and columns for each value that match

mat[2:length(mat)] # gives us a vector
mat[2:dim(mat)[1],]
mat[length(mat):1]

mat[1,-1] # throwaway values


```

</div>
</div>

```{r}
# modify

b = rep(0,3)
vec = c(vec,b)
vec
mat_2 = rbind(vec,vec)
mat_2 
mat_2 = cbind(mat_2,mat_2)
mat_2

t_mat = t(mat) # transposition
t_mat[2,3] = as.character(t_mat[2,3]) # all values turn to character


i_mat = diag(1, 3)
i_mat


```


</div>

<p>&nbsp;</p>

### Data frame

A Data frame in R is a matrix which can store different type of data, characters, numerics or factors. Contrary to the matrix it does not have a fixed dimension it means that we can create a column very easily using the operator '$'.

<div class = "r">

```{r,echo=T,collapse = TRUE}
# R

df = data.frame(chr = letters[1:5], # letters is a vector of letter provided directly in R
                num = seq(1,5,1),
                fac = factor(c(rep('a',3),rep('b',2)))) 
class(df$chr) # automaticaly converted to factor, which can be very inneficient !
df$chr = as.character(df$chr)
class(df$chr)
colnames(df)
df
# access the element of a variable in a df
df$chr[3]
which(df==3,
      arr.ind = TRUE) 

df[1:2] # gives us a df with the first two columns !
df[3:dim(df)[1],]

df[1,-1] # throwaway values

```
```{r,echo = T,collapse = TRUE}
# modify

b = rep(0,3)
df = rbind(df,b) # introduce a new row in the data frame, note that we get a NA in the factor colmun because '0' is not a level
df$new_col = rep(2,6) # we can introduce new colmuns by specifiying the name and set a value


df
t_df = t(df) # transposition convert the df into a matrix
class(t_df)
```
</div>

<p>&nbsp;</p>

### Arrays

Arrays is a generalisation of the matrix, it means that we can have a matrix with more than two dimension. we can modify them as we modify a matrix.

<div class = "r">

```{r,echo=T,collapse = TRUE}
# R

arr = array(seq(1,12,1), dim = c(2,2,3)) # create a matrix with 3 dimension
arr
# access the element of a dictionary
arr[1,,]
arr[,1,]
arr[,,1]
```
</div>


<p>&nbsp;</p>

### Lists 

A list permits us to assemble an assortment of disconnected objects behind one variable, it is also possible to store objects which can be of different types.


<div class = "r">

```{r,echo=T,collapse = TRUE}
# R

lst = list(df = df,
           mat = mat,
           arr = arr) # create a matrix with 3 dimension

lst
lst[[1]] # first element of the list, here it is the df
lst[[1]][1,] # first row of first element of the list
```
</div>



<p>&nbsp;</p>

## Other Data-Type (Python)

refused : https://thomas-cokelaer.info/tutorials/python/lists.html

In Python the most common are List, Turple, sets, Dictionnary.
Note that for the moment when modifiying a variable we always use '='. Keep in mind that using the '.' can modify the object behind the variable in Python.

<p>&nbsp;</p>

### Lists 

Keep in mind that Lists are mutable, as discussed in the Section "Difference between R and Python"

<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python

a = [1, 2, 3]
a.count(2) # count elements of the list which are exactly equal to 2

a.sort(reverse = True)
a
# access the element of a list
a[0]
a.index(3)
a[1:]
a[:1]
a[0:-1]
a[:]

```
```{python,echo = T,collapse = TRUE}
# modify

b = [0, 0, 0]
list(zip(a,b)) # zip will pairs the ellements, it works also with more than 2 element ex: zip(a,b,c)
a.append(b)
a
a[4:5] = ['a','b']
a
a.extend([4, 5, 6])
a
a += [7,8] # works as extend
a
a.insert(2,[1,2])
a
a.remove(b)
a

a = a*2 # replicate the list n times
len(a) # number of elements in the list

```
```{python,echo = T,collapse = TRUE}
# mutable

a = [1,2,3]
b = a
b[0] = 12
a

```
</div>



<p>&nbsp;</p>
### Turples

The main difference between Lists and Turples is the fact that Turples is an immutable type of data making it faster to use.

<div class = "python">
```{python,echo=T,collapse = TRUE}
# Python

a = (1, 2, 3)
a.count(2) # count elements of the turple which are exactly equal to 2

a
# access the element of a turple
a[0]
a.index(3)
a[1:]
a[:1]
a[0:-1]
a[:]

```
```{python,echo = T,collapse = TRUE}

# modify
a += (4,5) 
a
a = a*2 # replicate the turple n times
len(a) # number of elements in the turple

```
```{python,echo = T,collapse = TRUE}
# immutable

a = (1,2,3)
b = a
b[0] = 12
a

```
</div>


<p>&nbsp;</p>
### Dictionaries

Dictionary refers to a way of storing data that is not sorted. It works with key and value associate with this key.


<div class = "python">
```{python,echo=T,collapse = TRUE}
# Python

a = {'a':1, 'b':2, 'c':3}
# access the element of a dictionary
a.keys()
a['a']
a.values()
a.items()
a.get('a')
a.get('d',4) # set to 4 if the key 'd' is not detected

a.pop('a') # pop will use the corresponding value to the key a and remove the pair (key, value).
a
a.popitem('b')
a
```
```{python,echo = T,collapse = TRUE}
# modify
a['a'] =1 
a.setdefault('d',0) # create new item with a default value

b = {'d':4,'e':5}
a.update(b) # update values from other dict
a
a.clear() # remove all items

```
```{python,echo = T,collapse = TRUE}
# mutable

a = {'a':1, 'b':2, 'c':3}
b = a
b['b'] = [12,14]
a
```

</div>


<p>&nbsp;</p>
### Sets

Sets are unordered collection of unique elements. If we give to a set multiple time the same element it will automatically delete dupplicated values.


<div class = "python">
```{python,echo=T,collapse = TRUE}
# Python

a = {1, 2, 3}
a
# access the element of a set

a[0] # since it unordered, we can not access to a given element of a set


```
```{python,echo = T,collapse = TRUE}
# modify
b = {3,4,5}
a.update(b)  # update values from other set
a

```
```{python,echo = T,collapse = TRUE}
# mutable

a = {'a':1, 'b':2, 'c':3}
b = a
b['b'] = [12,14]
a
```

</div>


<p>&nbsp;</p>
### Arrays

In order to manipulate arrays in Python we need to use package numpy, this package is very usefull and will be covered in other chapters.

First see that we can make an array usig R by starting from a vector
R represents all arrays in column-major order, which is not the case in python.

<div class = "row">
<div class = "col-md-6">
<div class = "python">

```{python,echo=T,collapse = TRUE}
# Python

import numpy
arr = numpy.array([[1,4],[2,5],[3,6]])
arr

type(arr)

vec = [1,2,3,4,5,6]

arr = numpy.reshape(vec,(3,2))
arr
arr = numpy.reshape(vec,(3,2), order = 'F')
arr
```


</div>
</div>
<div class = "col-md-6">
<div class = "r">
```{r,echo = T,collapse = TRUE}
# R
arr = as.array(rbind(c(1,4),c(2,5),c(3,6)))
arr

vec = c(1,2,3,4,5,6)

arr = array(vec,dim = c(3,2))
arr
```
</div>
</div>
</div>

As ou can see R and Python does not store vector in the same way: R is storing them by column while python does it by row. Using "order = 'F'" alows us to store vecotr into matrix by column.


<div class = "python">
```{python,echo=T,collapse = TRUE}
# Python

# access the element of an array

arr[0] # access directly to the raw 1


```
```{python,echo = T,collapse = TRUE}
# modify
vec = [7,8]
arr = numpy.insert(arr, len(arr),vec,axis = 0)  # update values from other set
arr

```
```{python,echo = T,collapse = TRUE}
# mutable

arr2 = arr
arr2[0] = [12,14]
arr
```

</div>


<p>&nbsp;</p>
### Data Frame

Pandas Data Frames are also very common data-type in Python. The package Pandas is also view deeper in following chapters.

<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python

import pandas

df = pandas.DataFrame(arr)
df

type(df)

vec = [1,2,3,4,5,6]

df = pandas.DataFrame({'vec':vec,'vec1':range(2,8)})
df
```

</div>


<div class = "python">
```{python,echo=T,collapse = TRUE}
# Python

# access the element of a Pandas Data Frame

df['vec'] 

```
```{python,echo = T,collapse = TRUE}
# modify
vec2 = range(3,9)
df['vec2'] = vec2 # add values from other vector
a

```
```{python,echo = T,collapse = TRUE}
# mutable

df2 = df
df['vec'][0] = 30
df2
```

</div>


<p>&nbsp;</p>
# Control flow

There are two main control flow tools: choices, and loops. 
choices are very useful for establishing rules or conditions. Choices can be used to modify a value according to a certain condition, generally it allows to launch certain actions in specific cases.
The loops when it allows to execute sequentially actions, it can be to interactively modify an object, more generally it allows to launch a procedure several times. we can for example create N similar objects but we can also modify the N lines of an object.


## Choices



<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 

# if, elif, else

n = 12

if n%2 == 0 :  
  print('n is an even number')
  



if n != int(n): 
  print('n is not a integer')
elif  n%2 == 0 :
  print('n is an even number')
else:
  print('n is not an even number')
  
  

  
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R

# if, elif, else

n = 12L

if(n%%2 == 0){  
  print('n is an even number')
}
  



if(!is.integer(n)){ 
  print('n is not a integer')
  } else if(n%%2 == 0){
    print('n is an even number')
    } else {
      print('n is not an even number')
      }


  
```
</div>
</div>
</div>
 


<div class = "row">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R

# Fast version of ifelse()
x <- c(-3:3, NA)
if_else(condition = x < 0,
        true      = "neg",
        false     = "pos",
        missing   = "NA")


x <- c(-3:3, NA)
fifelse(test = x < 0,
        yes  = "neg",
        no   = "pos",
        na   = "NA")


# Vectorised ifelse statements


x <- 1:10
case_when(
  x %% 6 == 0 ~ "fizz buzz",
  x %% 2 == 0 ~ "fizz",
  x %% 3 == 0 ~ "buzz",
  TRUE ~ as.character(x)
)

```

</div>
</div>

<p>&nbsp;</p>
## Loops

Using for loops, we will iterate over a predefined number of iteration, sometimes we don't know how many steps we need to perform a given task. Imagine that we want to optimize a function, we don't know how many step we need until reaching an optimum but we can set a condition for which we will consider that the algorithm converged. For this kind of exercice we can use 'while' loops, it will iterate until a given condition is satisfied.


<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 

seq = [1,2,None,4,None,6]
total = 0

for val in seq:
  if val is not None:
    total += val
    
total
```

```{python,echo = T,collapse = TRUE}
# Python 
import random

total = 0
while total < 1:
  rnd = random.gauss(mu = 0, sigma = 1)
  if rnd < 0:
    pass
  else:
    total += rnd
  
total

```

</div>
</div>

<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R
seq = c(1,2,NA,4,NA,6)
total = 0

for(val in seq){
  if(!is.na(val)){
    total = total + val
  }
}
    
total
```


```{r,echo = T,collapse = TRUE}
# R

total = 0

while(total < 1){
  rnd = rnorm(n=1, mean = 0, sd = 1)
  if(rnd < 0){
    # in R we can specify nothing instead of specifiying 'pass'
    } else {
    total = total + rnd }
}
  
total
```

</div>
</div>
</div>

<p>&nbsp;</p>
## List, Set and Dict comprehensions (Python)

List comprehension is very common and appreciate in the python language features, think of it as a loop for which we will directly store output in a list, set, or dict. we can use it as a filter for exemple.


<div class = "python">
<div class = "row">
<div class = "col-md-6">
```{python,echo=T,collapse = TRUE}
# Python 
# List
import time

lst = [1,2,3,4]

t = time.time() 
results = []
for val in lst:
  if val > 2:
    results.append(val)
time.time()-t

results

t = time.time() 
# this loop their will produce the same output than a using List comprehension.
results = [val for val in lst if val>2]
time.time()-t

results
```
</div>
<div class = "col-md-6">
```{python,echo=T,collapse = TRUE}
# Python 
# Set
import time

st = {1,2,3,4}

t = time.time() 
results = set([])
for val in st:
  if val > 2:
    results.add(val)
time.time()-t

results

t = time.time() 

# this loop their will produce the same output than a using Set comprehension.
results = {val for val in st if val>2}
time.time()-t

results
```

</div>

<div class = "col-md-6">
```{python,echo=T,collapse = TRUE}
# Python 
# Dict
import time

dct = {'a':1,'b':2,'c':3,'d':4}

t = time.time() 
results = dict([])
for val in dct:
  if dct[val] > 2:
    results.update({str(val): dct[val]})
time.time()-t

results

t = time.time() 
# this loop their will produce the same output than a using Dict comprehension.
results = {str(val): dct[val] for val in dct if dct[val]>2}
time.time()-t

results
```

</div>
</div>
</div>










<p>&nbsp;</p>
# Functions


Functions are very important in both language, being able to code ourself things are sometimes more efficient that looking for a package and understand it.  
Being able to write our own function gives we more flexibility and a better understanding of what we are actually doing.   Most of the time, this sentence is wrong and the way we are googling things and reading documentation can also have a major role on ability to play with existent code.  
It's important to not reinvent the wheel, while it is important to be able to construct it ourself. Read documentation carefully while using packages, sometimes packages are misleading and we can spend a lot of time understanding how they work. Look at the packages source code when we are not sure of what the function does behind.  
The full power of programming comes with the fact that we can be autonomous by reading, modifying and writing codes and pre-existing codes.



<p>&nbsp;</p>
## General Functions 


<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 

seq = [1,2,None,4,None,6]*120

def clean_sum(seq):
  total = 0

  for val in seq:
    if val is not None:
      total += val
  return total
  
t = time.time()
clean_sum(seq =  seq)
time.time() - t


def clean_sum2(seq):
  total = sum(filter(None,seq))#[val for val in seq if val is not None])
  return total
  
t = time.time()
clean_sum2(seq =  seq)
time.time() - t


```

</div>
</div>

<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R
seq = rep(c(1,2,NA,4,NA,6),120)


clean_sum <- function(seq){
  total = 0
  for(val in seq){
    if(!is.na(val)){
      total = total + val
    }
  }
  return(total)
}

t = Sys.time()
clean_sum(seq = seq)
Sys.time() - t



clean_sum2 <- function(seq){
  total <- sum(na.rm(seq))
  return(total)
}

t <- Sys.time()
clean_sum(seq = seq)
Sys.time() - t



```


</div>
</div>
</div>


Functions in Python are objects, they can have attributes and methods like objects. The functions can have data variables and even functions written inside of them.  
Suppose we want to apply several transformation to data, we can create multiple functions to do the different task that we want to perform. we can stock functions in list a apply them sequentially very easily.  
Note that we can separate the output into several variables by specifiying the different values before the assignation. we cannot do that in R directly bt the zeallot package can tackle this problem.



<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 

def add_two(nb):
   nb = [i+2 for i in nb]
   return nb
  
def square_nb(nb):
   nb = [i**2 for i in nb]
   return nb

def global_function(nb):
   for function in func_list:
      nb = function(nb)
   return nb

func_list = [add_two,square_nb]

x1, x2 = global_function([2,3])
x1
x2
```

</div>
</div>

<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R
library(zeallot)

add_two <- function(nb){
  nb = nb + 2
  return(nb)
}
  
square_nb <- function(nb){
  nb = nb**2
  return(nb)
}

global_function <- function(nb){
  for(func in func_list){
    nb = func(nb)
      }
  return(nb)
}

func_list = c(add_two,square_nb)

c(x1, x2) %<-% global_function(c(2,3))
x1
x2
```


</div>
</div>
</div>


<p>&nbsp;</p>

## Python Generators

Generator usage in python is a simple way of creating iterators. The goal of this kind of function is to return an object for which we can iterate over it. The difference in terms of syntax hold in the fact that we will the statement 'yield' instead of 'return'. In comparaison to 'return', using 'yield' will pause the function and the control of that generator will be trasnfered to the object that call this generator.  
Generators are very very usefull when we deal with object taht can be too heavy to store all the information in our RAM.
As a generators is an iterator, it will load in the RAM only the iteration that it is reading, meaning that we can have no size limit if we want to iterate over an object that is to heavy.
This first example is made with a txt file with 1000 rows. We will see how RAM is used behind our machine to understand how it can be relevant to use genetaors. 


<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 
import os
import psutil
import re
process = psutil.Process(os.getpid())

t = time.time()
r1 = process.memory_info().rss 
def read_file_to_lower():
  with open("data/text.txt", "r") as txt:
    txt_list = txt.read().split('\n')
    txt_list_low = [re.sub(' ','',row.lower()) for row in txt_list] # re.sub here is used to modify each ' ' by nothing.
  return txt_list_low

txt_clean = read_file_to_lower()

process.memory_info().rss - r1 # in bytes
time.time() - t

type(txt_clean)

```

</div>
</div>

<div class = "col-md-6">
<div class = "python">

```{python,echo=T,collapse = TRUE}
# Python

process = psutil.Process(os.getpid())

t = time.time()
r1 = process.memory_info().rss 

def read_to_lower():
  with open("data/text.txt", "r") as txt:
    txt_line = txt.readline()
    while txt_line:
      txt_line = txt.readline()
      yield re.sub(' ','',txt_line.lower())


memory_friendly_txt_clean = read_to_lower()
txt_clean = [line_clean for line_clean in memory_friendly_txt_clean]

process.memory_info().rss - r1 # in bytes
time.time() - t


type(memory_friendly_txt_clean)



```

</div>
</div>
</div>


Note how the memory used during the calculation is very different while the time spend does not really change. 

<p>&nbsp;</p>

## Error and Exception Handling

Most of the time writing a function is very task specific, but since data are often dirty and incomplete, our given task may not work. It is important to understand why a given function can produce an error. Being sure that this and this case can leads to errors is not so easy, but it's important not to be too flexible to keep. In ths exemples we will see how setting the flexibility of the function can leads to different results that are more or less what we want.

Look before we leap vs Easier to ask for forgiveness than permission.

if we expect that 99 % of the time result will actually contain something iterable, I'd use the try/except approach. It will be faster if exceptions really are exceptional. If result is None more than 50 % of the time, then using if is probably better.
So, whereas an if statement always costs us, it's nearly free to set up a try/except block. But when an Exception actually occurs, the cost is much higher.

<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 
import numpy as np

# Let's create a function that create a dirty dict for which we want to calculate the sd in each cat
def create_dirty_list(None_prop):
  list_ = list()
  for i in range(10000):
    if i<None_prop*10000:
      list_.append([None])
    else:
      values = random.sample(range(1, 1000), random.sample(range(1, 50),1)[0])
      # introduce some character 
      if i%10==0 :
        values = [str(i) for i in values]
      list_.append(values)
  return list_

# let's create a function to return a tuple with the cat and the sd
def calc1(values):
  output = values[random.sample(range(1, len(values)+1),1)[0]-1]/values[random.sample(range(1, len(values)+1),1)[0]-1]
  return output

list_ = create_dirty_list(0.5)
# Store it in a list
results = [calc1(values) for  values in list_]

```

```{python,echo = T,collapse = TRUE}
# The issue seems to be the fact that a key has no values.
# Let's change the function

def calc2(values):
  if not any(value is None for value in values): 
    output = values[random.sample(range(1, len(values)+1),1)[0]-1]/values[random.sample(range(1, len(values)+1),1)[0]-1]
    return output

results = [calc2(values) for values in list_]

```

```{python,echo = T,collapse = TRUE}
# The issue seems to be the fact that a key has no values.
# Let's change the function

def calc3(values):
  if not any(value is None for value in values): 
    if all(isinstance(value,int) for value in values):
      output = values[random.sample(range(1, len(values)+1),1)[0]-1]/values[random.sample(range(1, len(values)+1),1)[0]-1]
      return output 

results = [calc3(values) for values in list_]

```

```{python,echo = T,collapse = TRUE}
# using try

def calc_try(values):
  try:
    output = values[random.sample(range(1, len(values)+1),1)[0]-1]/values[random.sample(range(1, len(values)+1),1)[0]-1]
  except:
    output = None
  return output
    
results = [calc_try(values) for values in list_]
```

 - Compare execution time 

```{python,echo = T,collapse = TRUE}
list_ = create_dirty_list(0.01)
t= time.time()
results = [calc3(values) for values in list_]
time.time()-t
t= time.time()
results = [calc_try(values) for values in list_]
time.time()-t

```

```{python,echo = T,collapse = TRUE}
list_ = create_dirty_list(0.33)
t= time.time()
results = [calc3(values) for values in list_]
time.time()-t
t= time.time()
results = [calc_try(values) for values in list_]
time.time()-t

```

```{python,echo = T,collapse = TRUE}
list_ = create_dirty_list(0.75)
t= time.time()
results = [calc3(values) for values in list_]
time.time()-t
t= time.time()
results = [calc_try(values) for values in list_]
time.time()-t

```

</div>
</div>

<div class = "col-md-6">
<div class = "r">

```{r,warning=F}
# R
# Let's create a function that create a dirty dict for which we want to calculate the sd in each cat
create_dirty_list <- function(None_prop){
  list_ <- list()
  for(i in seq(1,10000,1)){
    if(i<None_prop*10000){
      list_[[i]] <- c(NA)
      } else {
      values <- sample(seq(1,10000,1),round(runif(1,1,50)))
      # introduce some character 
      if(i%%10==0){
        values <- as.character(values)
      list_[[i]] <- values
      }
      }
  }
  return(list_)
  }
# let's create a function to return a tuple with the cat and the sd
calc1 <- function(values){
  output <- values[round(runif(1,1,length(values)))]/values[round(runif(1,1,length(values)))]
  return(output)
}

list_ <- create_dirty_list(0.5)
# Store it in a list
results <- lapply(list_,FUN = calc1)

```

```{r,warning=F}
# The issue seems to be the fact that a key has no values.
# Let's change the function

calc2 <- function(values){
  if(!any(is.na(values))){
    output <- values[round(runif(1,1,length(values)))]/values[round(runif(1,1,length(values)))]
    return(output)
  }
}


results <- lapply(list_,FUN = calc2)
```

```{r,warning=F}
# The issue seems to be the fact that a key has no values.
# Let's change the function

calc3 <- function(values){
  if(!any(is.na(values))){
    if(is.numeric(values)){
      output <- values[round(runif(1,1,length(values)))]/values[round(runif(1,1,length(values)))]
      return(output)
    }
  }
}



results <- lapply(list_,FUN = calc3)

```

```{r,echo = T,warning=F}
# using try

calc_try <- function(values){
  output <- tryCatch(
    {
      values[round(runif(1,1,length(values)))]/values[round(runif(1,1,length(values)))]
    }
    ,error=function(e){
      return(NA)
    })
  return(output)
}
    
results <- lapply(list_,FUN = calc_try)
```

 - Compare execution time

```{r,echo = T,warning=F}
 
list_ <- create_dirty_list(0.01)
t <- Sys.time()
results <- lapply(list_,FUN = calc3)
Sys.time()-t
t <- Sys.time()
results <- lapply(list_,FUN = calc_try)
Sys.time()-t

```

```{r,echo = T,warning=F}
# compare it 
list_ = create_dirty_list(0.33)
t <- Sys.time()
results <- lapply(list_,FUN = calc3)
Sys.time()-t
t <- Sys.time()
results <- lapply(list_,FUN = calc_try)
Sys.time()-t

```

```{r,echo = T,warning=F}
# compare it 
list_ = create_dirty_list(0.75)
t <- Sys.time()
results <- lapply(list_,FUN = calc3)
Sys.time()-t
t <- Sys.time()
results <- lapply(list_,FUN = calc_try)
Sys.time()-t

```
</div>
</div>
</div>


https://www.w3schools.com/python/python_ref_string.asp
https://thomas-cokelaer.info/tutorials/python/strings.html

<p>&nbsp;</p>

# Exercices


