<style>
div.python pre { background-color: #fdfcff; }
</style>

<style>
div.r pre { background-color: #fffffc; }
</style>

http://eric.univ-lyon2.fr/~ricco/tanagra/fichiers/fr_Tanagra_R_Python_Data_Perfs.pdf
https://juba.github.io/tidyverse/06-tidyverse.html
http://python-simple.com/python-pandas/panda-intro.php

"It is often said that 80% of data analysis is spent on the process of cleaning and preparing the data (Dasu and Johnson 2003).  Data preparation is not just a first step,  but must berepeated many times over the course of analysis as new problems come to light or new datais collected." [(Wickham, 2014)](https://www.jstatsoft.org/article/view/v059i10).
Data can be structured or unstructered, There is a lot of different ways of storing data as seen in other lessons this semester. Here We will focus on using structured data from txt or csv format for simplicity, csv are just delimited text file with comma.
We need to be able to open and treat data whatever the type of data that we are dealing with, sometimes it's easier to transform data in a way that we are use to work with. Sometimes it's unapropriate and you can corrupt or miss information in the data base, it's important to read documentation if you are in front of a new data formating type. 


# R


The Tidyverse is a collection of differents packages which works together in a common philosophy, the biggest contributor to this collection is named Hadley Wickham. Hadley Wickham did so much for the R community, he published a lot of books  that I highly recommend to read. Check [Wikipedia: Haldey Wickham](https://en.wikipedia.org/wiki/Hadley_Wickham) for his bibliograpy. Here is the list of libraries that are contained in the Tidyverse:
- ggplot2: Visualization
- dplyr: Data manipulation
- tidyr: Data formatting
- purrr: programming
- readr: Data importation
- tibble: Data tables
- forcats: Qualitative variables
- stringr: Strings

The goal of tidyverse is to make easy data analysis by simplifying the data preparation. Tidyverse comes with a new data-type, Tibbles. 

Tibbles can be considered a modern version of data.frame but they differs in some aspects. They do not have rowname and allows users to have colnames with special character (e.g. if colname of x is 'Col 1' then to access to this colnums you can use x$\`Col 1\` to acces to this variables.). It provide a good way also to visualize the data since it directly show data as if you were running the 'head()' function before. It shows you the 10 first rows.

Data.table is also very common when dealing with data and is very fast. Using tibbles can be very time consuming when dealing with large tables.

##  Read/Write data 

<div class = "r">

```{r,echo=T,collapse = TRUE}
# R
library(tidyverse)

covid_papers <- read_csv("data/covid_papers.csv")

covid_papers

```
</div>

Depending on the way string are encoded we may want to precise the type of encoding. (Some well know encoding character format: UTF-8; Unicode; ASCII ..)


we can sepcify this encoding in the read function.
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R
covid_papers <- read_csv("data/covid_papers.csv",locale = locale(encoding = "UTF-8"))
```
</div>
 
Other types of data can be import using other libraries I just show you some examples here without enterring into details that may be helpfull sometimes.

- Excel data

<div class = "r">
```{r,echo=T,collapse = TRUE,eval=F}
# R
library(readxl)

covid_papers <- read_excel("data/covid_papers.xls", sheet = "Feuille1", range = "A1:Z25")
```
</div>

-  SAS, SPSS et Stata data

<div class = "r">

```{r,echo=T,collapse = TRUE,eval=F}
# R
library(haven)

#SAS data
covid_papers <- read_sas("data/covid_papers.sas")
covid_papers <- read_xpt("data/covid_papers.xpt")

#SPSS data
covid_papers <- read_sav("data/covid_papers.sav")
covid_papers <- read_por("data/covid_papers.por")



```
</div>

In order to save data in a specific format we just have to change the 'read' part of the function name by 'write'. Here is an example for csv


<div class = "r">

```{r,echo=T,collapse = TRUE,eval=F}
# R

write_csv(new_data_set,"data/new_data.csv")


```
</div>

## RData

Also R provide a way to store objects in the same file. For this we use RData format, it's very usefull if a project is written totaly in R because you can save the structure of your objects very easily, you can save all type of objects and load it later.
 

<div class = "r">

```{r,echo=T,collapse = TRUE,eval=F}
# R

save(covid_papers,file= 'covid_papers.RData')
load('covid_papers.RData')


```
</div>

## Data Manipulation

Dplyr is very friendly, it use very understandable words to manipulate data. It uses a very specific way of writting calculation, the pipe : '%>%'. Pipes allows us to writte sequential calculation in a quiet readable way. Here is how we need to read R code that use pipes: 

- <b> Usual Way </b>  
funtion2(function1(dataset,arg1),arg2)

- <b> Using Pipes </b>  
dataset %>% function1(arg1) %>% function2(arg2)

Note that we can write directly '%>%' by using 'ctrl + shift + m'

Here is list of function that are commonly used and actions they provide.

Functions | Description
- | -:
slice | restrict dataset to specific row (see also slice_head, slice_tail, slice_min, slice_max)
slice_sample | restrict dataset to random row
filter | restrict dataset to row that pass a condition
select | restrict dataset to specifiyed columns
rename | change columns names
arrange | sort dataset with respect to one columns
mutate | modify or create a columns that apply a function
group_by | group data before running calculation
ungroup | ungroup data
summarise | summarise data with respect to the level of agregation (groups)
count | count numbers of row in a group 
lead/lag | shift the observations of a variable one notch backwards (for lead) or forwards (for lag)
distinct | given a varaiable restrict the dataset to unique value of this variable
bind_rows/bind_cols | add columns or rows  to the dataset
left_join | merge datatables with respect to variable(s) (see also full_join, inner_join, anti_join)
starts_with

- <b> Usual Way </b>

<div class = "r">

```{r,echo = T,collapse = TRUE}
# R
which(is.na(covid_papers),arr.ind = T)
covid_papers = na.omit(covid_papers)

slice(covid_papers,2)
slice_sample(covid_papers,prop = 0.001)

t <- Sys.time()
doi_clean <- filter(covid_papers,doi != 'null')
Sys.time()-t

```


<b> Using Pipes </b>  

```{r,echo=T,collapse = TRUE}
# R

covid_papers %>% slice(2)
covid_papers %>% slice_sample(prop = 0.001)

t = Sys.time()
doi_clean <- covid_papers %>% filter(doi != 'null')
Sys.time() - t

t = Sys.time()
doi_clean <- covid_papers[which(covid_papers$doi != 'null'),]
Sys.time() - t


```

</div>


## Tibbles and data.tables

https://atrebas.github.io/post/2019-03-03-datatable-dplyr/


### Basic operations

#### Select columns
<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles
cp_tibble <-  as_tibble(covid_papers)

head(cp_tibble[[4]]) # returns a vector
head(cp_tibble[4])# returns a tibble

head(select(cp_tibble, doi)) # returns a tibble
head(pull(cp_tibble, doi, name = title))   # returns a (named) vector
head(cp_tibble[, "doi"])        # returns a tibble
head(cp_tibble[["doi"]])        # returns a vector

head(select(cp_tibble, doi, creation, title))
head(select(cp_tibble, doi:title)) # select columns between doi and title

head(select(cp_tibble, -doi, -creation))

cols <- c("doi", "creation")
head(select(cp_tibble, !!cols)) # unquoting
head(select(cp_tibble, -!!cols))
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table
library(data.table)
cp_datatable = as.data.table(covid_papers)

head(cp_datatable[[4]]) # returns a vector
head(cp_datatable[, 4])  # returns a data.table

head(cp_datatable[, list(doi)]) # returns a data.table
head(cp_datatable[, .(doi)])    # returns a data.table
# . is an alias for list

head(cp_datatable[, "doi"])     # returns a data.table
head(cp_datatable[, doi])       # returns a vector
head(cp_datatable[["doi"]])     # returns a vector

head(cp_datatable[, .(doi, creation, title)])
head(cp_datatable[, list(doi, creation, title)])
head(cp_datatable[, doi:title]) # select columns between doi and title

head(cp_datatable[, !c("doi", "creation")])

cols <- c("doi", "creation")
head(cp_datatable[, ..cols]) # .. prefix means 'one-level up'
head(cp_datatable[, !..cols]) # or cp_datatable[, -..cols]
```

</div>
</div>
</div>

 - using regular expression
 
<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles
colnames(cp_tibble)[1:3] <- paste0('V',c(1:3))

select(cp_tibble, num_range("V", 1:2))
select(cp_tibble, title, everything()) # reorder columns
select(cp_tibble, contains("V"))
select(cp_tibble, ends_with("3"))
select(cp_tibble, matches(".2"))
select(cp_tibble, one_of(c("V1", "X")))
select(cp_tibble, -starts_with("doi"))
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table
colnames(cp_datatable)[1:3] <- paste0('V',c(1:3))

cols <- paste0("V", 1:2)
cols <- union("title", names(cp_datatable))
cols <- grep("V",   names(cp_datatable))
cols <- grep("3$",  names(cp_datatable))
cols <- grep(".2",  names(cp_datatable))
cols <- grep("^V1|X$",  names(cp_datatable))
cols <- grep("^(?!doi)", names(cp_datatable), perl = TRUE)
cp_datatable[, ..cols]
```

</div>
</div>
</div>

#### Filtering
<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles


cp_tibble[3:4,]
slice(cp_tibble, 3:4) # same

cp_tibble[-(3:7),]
slice(cp_tibble, -(3:7)) # same

dim(filter(cp_tibble, year_pub > 2018))
filter(cp_tibble, title %in% c("Deep convolutional approaches for the analysis of Covid-19 using chest X-Ray images from portable devices",
                               "Evaluating the effect of city lock-down on controlling COVID-19 propagation through deep learning and network science models."))

filter(cp_tibble, year_pub == 2019, title == "Deep convolutional approaches for the analysis of Covid-19 using chest X-Ray images from portable devices")

dim(distinct(cp_tibble)) # distinct_all(cp_tibble)
dim(distinct(cp_tibble, across(c(V1, title)))) # returns selected cols

dim(tidyr::drop_na(cp_tibble, names(cp_tibble)[1:4]))


dim(filter(cp_tibble, grepl("deep learning", title)))
dim(filter(cp_tibble, dplyr::between(year_pub, 2015, 2017)))
dim(filter(cp_tibble, year_pub > 2015 & year_pub < 2017))
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table
library(data.table)

cp_datatable[3:4,]
cp_datatable[3:4] # same

cp_datatable[!3:7,]
cp_datatable[-(3:7)] # same

dim(cp_datatable[year_pub > 2018])
cp_datatable[title %chin% c("Deep convolutional approaches for the analysis of Covid-19 using chest X-Ray images from portable devices",
                               "Evaluating the effect of city lock-down on controlling COVID-19 propagation through deep learning and network science models.")] # fast %in% for character

cp_datatable[year_pub == 2019 & title == "Deep convolutional approaches for the analysis of Covid-19 using chest X-Ray images from portable devices"]

dim(unique(cp_datatable))
dim(unique(cp_datatable, by = c("V1", "title"))) # returns all cols

dim(na.omit(cp_datatable, cols = 1:4))  # fast S3 method with cols argument

dim(cp_datatable[title %like% "deep learning"])
dim(cp_datatable[year_pub %between% c(2015, 2017)])
dim(cp_datatable[data.table::between(year_pub, 2015, 2017, incbounds = FALSE)])

```

</div>
</div>
</div>

On the other hand, data.table also provides convenience functions to filter rows based on a regular expression or to find values lying in one (or several) interval(s).

Below, we will see that data.table has two optimized mechanisms to filter rows efficiently (keys and indices).

#### Sorting

<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles
cp_tibble %>% arrange(creation) %>% select(creation)
cp_tibble %>% arrange(desc(creation)) %>% select(creation)

arrange(cp_tibble, year_pub, desc(creation)) %>% select(year_pub,creation)
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table

cp_datatable[order(creation)] 
cp_datatable[order(-creation)]

cp_datatable[order(year_pub, -creation)]
```

</div>
</div>
</div>


#### Summarise data


<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles
n_distinct(cp_tibble)

cp_tibble %>% summarise(sum(cited)) # returns a tibble
cp_tibble %>% summarise(sum_citation = sum(cited)) # returns a tibble

summarise(cp_tibble, sum(cited), sd(cited))

cp_tibble %>%
  summarise(sum_citation = sum(cited),
            sd_citation = sd(creation))

cp_tibble %>%
  slice(1:4) %>%
  summarise(sum(cited))

cp_tibble %>% summarise(dplyr::first(year_pub))
cp_tibble %>% summarise(dplyr::last(year_pub))
cp_tibble %>% summarise(nth(year_pub, 5))
cp_tibble %>% summarise(n_distinct(language))
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table

uniqueN(cp_datatable)

cp_datatable[, sum(cited)]    # returns a vector
cp_datatable[, .(sum(cited))] # returns a data.table
cp_datatable[, .(sum_citation = sum(cited))] # returns a data.table

cp_datatable[, .(sum(cited), sd(cited))]

cp_datatable[, .(sum_citation = sum(cited),
                 sd_citation  = sd(cited))]

cp_datatable[1:4, sum(cited)]

cp_datatable[, data.table::first(year_pub)]
cp_datatable[, data.table::last(year_pub)]
cp_datatable[5, year_pub]
cp_datatable[, uniqueN(language)]
```

</div>
</div>
</div>

dplyr helper functions for summarise() (or summarize()) include first(), last(), n(), nth(), and n_distinct(). The data.table package also include first(), last(), and uniqueN().


#### Add/update/delete columns
In the following commands, with data.table, columns are modified by reference using the column assignment symbol := (no copy performed) and the results are returned invisibly. With dplyr, we have to assign the results.


<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles
cp_tibble %>% select(oa)
cp_tibble <- cp_tibble %>% mutate(oa = ifelse(oa == 'Y',1,0), log_cited = log(cited + 1))
cp_tibble %>% select(oa,log_cited)


# Create one column and remove the others
transmute(cp_tibble, title_lower = tolower(title))

cp_tibble <- cp_tibble %>% select(-V1, -V2)

cols <- c('V3','doi')
cp_tibble <- select(cp_tibble, -one_of(cols))
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table
cp_datatable[, c('oa','log_cited') := .(ifelse(oa == 'Y',1,0),log(cited+1))]
cp_datatable[,oa,log_cited]


# Create one column and remove the others
cp_datatable[, .(title_lower = tolower(title))]

cp_datatable[, c('V1', 'V2') := NULL]

cols <- c('V3','doi')
cp_datatable[, (cols) := NULL] # ! not cp_datatable[, cols := NULL]
```

</div>
</div>
</div>



#### Grouping 
by
The dplyr::group_by() function and the corresponding by and keyby statements in data.table allow to run manipulate each group of observations and combine the results. The sole difference between by and keyby is that keyby orders the results and creates a key that will allow faster subsetting (cf. the indexing and keys section). Below, we arbitrary use one or the other.
group_by() takes an existing tibble and converts it into a grouped tibble where operations will always be performed “by group”. Using ungroup() removes grouping. With data.table, by is always used on the fly.
Note that it is possible to reorder the arguments in data.table: cp_datatable[i, j, by] <=> cp_datatable[i, by, j]. This is done below to better highlight the similarity with dplyr.

<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles
cp_tibble <-  as_tibble(covid_papers) %>% filter(pmid!='null')

cp_tibble %>%
  group_by(year_pub) %>%
  summarise(nb_language = length(unique(language)))

# By several groups
cp_tibble %>%
  group_by(year_pub, source) %>%
  summarise(mean_cited = mean(cited))

# Assigning column name in by
cp_tibble %>%
  group_by(PY = as.numeric(year_pub)) %>%
  summarise(sum_cited = sum(cited))

# Using a condition
cp_tibble %>%
  group_by(source == "MED") %>%
  summarise(mean(cited))

# Count number of observations for each group
cp_tibble %>%
  group_by(source) %>%
  tally()

cp_tibble %>%
  group_by(source) %>%
  summarise(n())

cp_tibble %>%
  group_by(source) %>%
  group_size() # returns a vector

# Add a column with number of observations for each group
add_count(cp_tibble, year_pub) %>% select(year_pub,n)
cp_tibble %>%
  group_by(year_pub) %>%
  add_tally()
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table

cp_datatable <-  as.data.table(covid_papers)[pmid!='null',]

cp_datatable[, .(nb_language = length(unique(language))), by = "year_pub"]

# By several groups
cp_datatable[, keyby = .(year_pub, source),
     .(mean_cited = mean(cited))]

# Assigning column name in by
cp_datatable[, keyby = .(PY = as.numeric(year_pub)),
     .(sum_cited = sum(cited))]

# Using a condition in by
cp_datatable[, keyby = source == "MED",
     mean(cited)]

# Count number of observations for each group
cp_datatable[, .N, by = source]
count(cp_tibble, source)

# Add a column with number of observations for each group
cp_datatable[, n := .N, by = source][]

```

</div>
</div>
</div>


#### Advanced columns manipulation
To manipulate multiple columns, dplyr_1.0.0 has introduced the across() function, superseding the _all, _at, and _if versions of summarise(), mutate(), and transmute().
With data.table, we use .SD, which is a data.table containing the Subset of Data for each group, excluding the column(s) used in by. So, cp_datatable[, .SD] is cp_datatable itself and in the expression cp_datatable[, .SD, by = title], .SD contains all the cp_datatable columns (except title) for each values in title (see cp_datatable[, print(.SD), by = title]). .SDcols allows to select the columns included in .SD.


<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles

cp_tibble <- cp_tibble %>% mutate(PY = as.numeric(year_pub),log_cited =log(cited+1))
# Summarise several columns
cp_tibble %>% summarise(across(c(PY, cited), mean))


# Summarise several columns by group
cp_tibble %>%
  group_by(source) %>%
  summarise(across(c(PY, cited), mean))

## using patterns (regex)
cp_tibble %>%
  group_by(source) %>%
  summarise(across(ends_with('cited'), mean))

# Summarise with more than one function by group
cp_tibble %>%
  group_by(source) %>%
  summarise(across(c(PY, cited),
                   list(median = median, mean = mean)))

# Summarise using a condition
cp_tibble %>%
  summarise(across(where(is.numeric),
                   mean))

cp_tibble  %>%
  group_by(source) %>%
  summarise(across(where(~ is.numeric(.x) && median(.x)>0), 
                        median))
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table
cp_datatable[,c('PY','log_cited') := .(as.numeric(year_pub),log(cited+1))]

# Summarise several columns
cp_datatable[, lapply(.SD, mean),
     .SDcols = c('PY', 'cited')]

# Summarise several columns by group
cp_datatable[, by = source,
     lapply(.SD, mean),
     .SDcols = c('PY', 'cited')]
## using patterns (regex)

cp_datatable[, by = source,
     lapply(.SD, mean),
     .SDcols = patterns("cited")]


# Summarise with more than one function by group
cp_datatable[, by = source,
     c(lapply(.SD, median),
       lapply(.SD, mean)),
     .SDcols = c('PY', 'cited')]


# Summarise using a condition
cp_datatable[, sapply(cp_datatable, is.numeric),with = FALSE][,lapply(.SD, mean)]

foo <- function(x) {is.numeric(x) && median(x)>0}

cp_datatable[, sapply(cp_datatable, foo),with = FALSE][,lapply(.SD, mean)]
```

</div>
</div>
</div>

#### Modify Multiples Variables

<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}

tobinary = function(x){ifelse(x=='Y',1,0)}

# Modify several columns (dropping the others)
cp_tibble %>% transmute(across(c(has_data, oa),
                 tobinary))


# Modify several columns (keeping the others)
cp_tibble <- cp_tibble %>%
  mutate(across(all_of(c('pubtype','mesh')),
                 ~ tolower(str_replace_all(.x,'-',''))))
cp_tibble %>% select(pubtype,mesh)

# Modify columns using a condition

t = Sys.time()
cp_tibble <- cp_tibble %>%
  mutate(across(where(is.character),
         toupper))
Sys.time() - t
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# Modify several columns (dropping the others)
cp_datatable[, lapply(.SD, tobinary),
     .SDcols = c('has_data', 'oa')]


# Modify several columns (keeping the others)
cp_datatable[, c('pubtype','mesh') := lapply(.SD, function(x){tolower(str_replace_all(x,'-',''))}),#cols <- setdiff(names(cp_datatable), "title")
     .SDcols = c('pubtype','mesh') ]
cp_datatable

# Modify columns using a condition 
t = Sys.time()
for (j in  which(sapply(cp_datatable, class)=='character')) set(cp_datatable, i=NULL, j=j, value=tolower(cp_datatable[[j]]))
Sys.time() - t 
```

</div>
</div>
</div>

The use of cp_datatable[,j] is very flexible, allowing to pass complex expressions in a straightforward way, or combine expressions with multiple outputs.

#### More complex expression


<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles

cp_tibble %>%
  mutate(is_en = ifelse(language =='eng',1,0)) %>%
  group_by(year_pub)  %>% 
  summarize(sum_en = sum(is_en),
            share_en = sum_en/n())

```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table

cp_datatable[,c('is_en','oa') := .(ifelse(language =='eng',1,0),
                              ifelse(oa =='Y',1,0))][
                                ,by = year_pub,.(sum_en = sum(is_en),
                                                 share_en = sum(is_en)/.N)]

# Use multiple expressions (with cp_datatable[,{j}])
cp_datatable[, {is_en = ifelse(language =='eng',1,0)
      en_data = is_en + oa
     .(eng_oa = ifelse(en_data == 2, 1,0)) # last list returned as a data.table
     }]
```

</div>
</div>
</div>


# Chain expressions
The dplyr workflow relies on the magrittr pipe operator (%>%). The magrittr package can also be used with data.table objects, but data.table comes with its own chaining system: cp_datatable[ ... ][ ... ][ ... ].

Expression chaining using cp_datatable[][] (recommended)
cp_datatable[, by = title, 
     .(V1sum = sum(V1)) ][
     V1sum > 5]
cp_tibble %>%
  group_by(title) %>%
  summarise(V1sum = sum(V1)) %>%
  filter(V1sum > 5)
Expression chaining using %>%
cp_datatable[, by = title, 
     .(V1sum = sum(V1))] %>%
  .[order(-V1sum)]
cp_tibble %>%
  group_by(title) %>%
  summarise(V1sum = sum(V1)) %>%
  arrange(desc(V1sum))

Indexing and Keys
Row subsetting in dplyr relies on the filter() and slice() functions, as shown in the first section. With data.table, in addition to the above-mentioned approach, two systems are available to make row filtering and join operations more convenient and blazingly fast (~170x speed-up): keys (primary ordered index) and indices (automatic secondary indexing).

The main differences between keys and indices are:
- When using keys, data are physically reordered in memory. When using indices, the order is stored as an attribute.
- Only one key is possible but several indices can coexist.
- Keys are defined explicitly. Indices can be created manually but are also created on-the-fly (and stored when using == or %in%).
- Indices are used with the on argument. It is optional when using keys, but recommended (and used below) for better readability.
Note: in the following code, we set both a key and an index to demonstrate their usage, but internally, indices are not used when a key already exists for the same columns(s).

Set the key/index
setkey(cp_datatable, title)
setindex(cp_datatable, title)
cp_datatable
cp_tibble <- arrange(cp_tibble, title) # ordered just for consistency
cp_tibble
Select the matching rows
cp_datatable["A", on = "title"]
cp_datatable[c("A", "C"), on = .(title)] # same as on = "title"
filter(cp_tibble, title == "A")
filter(cp_tibble, title %in% c("A", "C"))
Select the first matching row
cp_datatable["B", on = "title", mult = "first"]
cp_datatable[c("B", "C"), on = "title", mult = "first"]
cp_tibble %>%
  filter(title == "B") %>%
  slice(1)
# ?
Select the last matching row
cp_datatable["A", on = "title", mult = "last"]
cp_tibble %>%
  filter(title == "A") %>%
  slice(n())
Nomatch argument
# (default) returns a row with "D" even if not found
cp_datatable[c("A", "D"), on = "title", nomatch = NA]
# no rows for unmatched values
cp_datatable[c("A", "D"), on = "title", nomatch = 0]
#
filter(cp_tibble, title %in% c("A", "D"))
Apply a function on the matching rows
cp_datatable[c("A", "C"), sum(V1), on = "title"]
cp_tibble %>%
  filter(title %in% c("A", "C")) %>%
  summarise(sum(V1))
Modify values for matching rows
cp_datatable["A", V1 := 0, on = "title"]
cp_datatable
cp_tibble <- cp_tibble %>%
  mutate(V1 = base::replace(V1, title == "A", 0L)) %>%
  arrange(title)
cp_tibble
Use keys in by
cp_datatable[!"B", sum(V1), on = "title", by = .EACHI]
cp_datatable[title != "B",
   by = title,
   sum(V1)]   # same
cp_tibble %>%
  filter(title != "B") %>%
  group_by(title) %>%
  summarise(sum(V1))
Set keys/indices for multiple columns
setkey(cp_datatable, title, V1) # or setkeyv(cp_datatable, c("title", "V1"))
setindex(cp_datatable, title, V1) # setindexv(cp_datatable, c("title", "V1"))
cp_datatable
cp_tibble <- arrange(cp_tibble, title, V1) # ordered just for consistency
cp_tibble
Subset using multiple keys/indices
cp_datatable[.("C", 1), on = .(title, V1)]
cp_datatable[.(c("B", "C"), 1), on = .(title, V1)]
# using which = TRUE only returns the matching rows indices
cp_datatable[.(c("B", "C"), 1), on = .(title, V1), which = TRUE]
filter(cp_tibble, V1 == 1, title == "C")
filter(cp_tibble, V1 == 1, title %in% c("B", "C"))
# ?
Remove keys/indices
setkey(cp_datatable, NULL)
setindex(cp_datatable, NULL)
cp_datatable
# 
cp_tibble

set*() modifications
In data.table, set*() functions modify objects by reference, making these operations fast and memory-efficient. In case this is not a desired behaviour, users can use copy(). The corresponding expressions in dplyr will be less memory-efficient.

Replace values
set(cp_datatable, i = 1L, j = 2L, value = 3L)
cp_datatable
cp_tibble[1, 2] <- 3L
cp_tibble
Reorder rows
setorder(cp_datatable, title, -V1)
setorderv(cp_datatable, c("title", "V1"), c(1, -1))
cp_tibble <- arrange(cp_tibble, title, desc(V1))
Modify colnames
setnames(cp_datatable, old = "doi", new = "doi")
setnames(cp_datatable, old = -(c(1, 3)), new = "doi")
cp_datatable
cp_tibble <- rename(cp_tibble, doi = doi)
cp_tibble <- rename(cp_tibble, doi = doi) # reset upper
cp_tibble
Reorder columns
setcolorder(cp_datatable, c("title", "V1", "doi"))
cp_datatable
cp_tibble <- select(cp_tibble, title, V1, doi)
cp_tibble
Relocate columns
# coming soon (#4358)
cp_tibble %>%
  relocate(title, .after = doi)
Convert data
# ?setcp_datatable # data.frame or list to data.table
# ?setcp_tibble # data.table to data.frame
# ?setattr # modify attributes
# 

Advanced use of by
Context dependent expressions (cur_*()) have been introduced in dplyr 1.0.0, reflecting data.table aliases .I, .GRP, …

Select first/last/… row by group
cp_datatable[, .SD[1], by = title]
cp_datatable[, .SD[c(1, .N)], by = title]
cp_datatable[, tail(.SD, 2), by = title]
cp_tibble %>%
  group_by(title) %>%
  slice(1)
cp_tibble %>%
  group_by(title) %>%
  slice(1, n())
cp_tibble %>%
  group_by(title) %>%
  group_map(~ tail(.x, 2))
Select rows using a nested query
cp_datatable[, .SD[which.min(doi)], by = title]
cp_tibble %>%
  group_by(title) %>%
  arrange(doi) %>%
  slice(1)
Add a group counter column
cp_datatable[, Grp := .GRP, by = .(title, V1)][]
cp_datatable[, Grp := NULL] # delete for consistency
cp_tibble %>%
  group_by(title, V1) %>%
  mutate(Grp = cur_group_id())
# cp_tibble %>% mutate(Grp = group_indices(., title, V1))
Get row number of first (and last) observation by group
cp_datatable[, .I, by = title] # returns a data.table
cp_datatable[, .I[1], by = title]
cp_datatable[, .I[c(1, .N)], by = title]
cp_tibble %>%
  group_by(title) %>%
  mutate(cur_group_rows())
#cp_tibble %>%
#  group_by(title) %>%
#  group_data() %>%
#  tidyr::unnest(.rows)
cp_tibble %>%
  group_by(title) %>%
  summarize(cur_group_rows()[1])
cp_tibble %>%
  group_by(title) %>%
  summarize(cur_group_rows()[c(1, n())])
# cp_tibble %>% group_by(title) %>% group_rows() # returns a list
Handle list-columns by group
cp_datatable[, .(.(V1)),  by = title]  # return V1 as a list
cp_datatable[, .(.(.SD)), by = title] # subsets of the data
cp_tibble %>%
  group_by(title) %>%
  summarise(list(V1))
cp_tibble %>%
  group_by(title) %>%
  group_nest()
Grouping sets (multiple by at once)
rollup(cp_datatable,
       .(Sumdoi = sum(doi)),
       by = c("V1", "title"))

rollup(cp_datatable,
       .(Sumdoi = sum(doi), .N),
       by = c("V1", "title"),
       id = TRUE)

cube(cp_datatable,
     .(Sumdoi = sum(doi), .N),
     by = c("V1", "title"),
     id = TRUE)

groupingsets(cp_datatable,
             .(Sumdoi = sum(doi), .N),
             by   = c("V1", "title"),
             sets = list("V1", c("V1", "title")),
             id   = TRUE)
#

https://cran.r-project.org/web/packages/data.table/vignettes/datatable-sd-usage.html


# Pandas (Python)


https://medium.com/bigdatarepublic/advanced-pandas-optimize-speed-and-memory-a654b53be6c2