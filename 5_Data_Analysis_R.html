<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Data Analysis (R)</title>

<script src="site_libs/header-attrs-2.16/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/font-awesome-5.13.0/js/script.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">M1 Programming</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="2_Basics.html">Basics</a>
</li>
<li>
  <a href="3_Arrays_Vectors.html">Arrays/Vectors</a>
</li>
<li>
  <a href="4_Regex.html">Regex</a>
</li>
<li>
  <a href="5_Data_Analysis_R.html">Data Analysis (R)</a>
</li>
<li>
  <a href="6_Data_Analysis_Py.html">Data Analysis (Python)</a>
</li>
<li>
  <a href="7_Best_practices.html">Best Pratices</a>
</li>
<li>
  <a href="8_Efficient_prog.html">Efficient Prog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/master-ds2e/">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Data Analysis (R)</h1>

</div>


<style>
div.python pre { background-color: #e9f7f5
; }
</style>
<style>
div.r pre { background-color: #fff5fd; }
</style>
<a href="https://github.com/master-ds2e/M1-Programming/raw/gh-pages/data/covid_papers.zip">
<button class="btn btn-danger"><i class="fa fa-save"></i> Download Data</button>
</a>
<p>“It is often said that 80% of data analysis is spent on the process of cleaning and preparing the data (Dasu and Johnson 2003). Data preparation is not just a first step, but must berepeated many times over the course of analysis as new problems come to light or new data is collected.” <a href="https://www.jstatsoft.org/article/view/v059i10">(Wickham, 2014)</a>.</p>
<p>The Tidyverse is a collection of differents packages which works together in a common philosophy, the biggest contributor to this collection is named Hadley Wickham. Hadley Wickham did so much for the R community, he published a lot of books that are highly recommended to read. Check <a href="https://en.wikipedia.org/wiki/Hadley_Wickham">Wikipedia: Haldey Wickham</a> for his bibliograpy. Here is the list of libraries that are contained in the Tidyverse:</p>
<ul>
<li><p>ggplot2: Visualization</p></li>
<li><p>dplyr: Data manipulation</p></li>
<li><p>tidyr: Data formatting</p></li>
<li><p>purrr: programming</p></li>
<li><p>readr: Data importation</p></li>
<li><p>tibble: Data tables</p></li>
<li><p>forcats: Qualitative variables</p></li>
<li><p>stringr: Strings The goal of the tidyverse is to make data analysis easier by simplifying data preparation. Tidyverse includes a new data type, Tibbles.</p></li>
</ul>
<p>Tibbles can be considered a modern version of data.frame, but they differ in some aspects. They do not have row names and allow users to have column names with special characters (e.g. if the column name of x is ‘Col 1’, then to access this column you can use x$`Col 1` to access this variable). Tibbles also provide a good way to visualize data since it directly shows data as if you were running the ‘head()’ function before, displaying the first 10 rows.</p>
<p>Data.table is also a common choice when dealing with data and it is very fast. However, using Tibbles can be time-consuming when dealing with large tables.</p>
<div id="tibbles-and-data.tables" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Tibbles and data.tables</h1>
<div id="basic-operations" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Basic Operations</h2>
<div id="pipes" class="section level3" number="1.1.1">
<h3><span class="header-section-number">1.1.1</span> Pipes</h3>
<p>Dplyr is user-friendly as it uses very understandable words to manipulate data. It uses a specific way of writing calculations called the pipe operator: ‘%&gt;%’. Pipes allow us to write sequential calculations in a readable way. Here is how we need to read R code that uses pipes: The code on the left side of the pipe operator is passed as the first argument to the function on the right side of the operator. This allows for a more readable and concise way of performing multiple operations on data, as it eliminates the need to create intermediate variables and makes the code more readable by showing the flow of data.</p>
<ul>
<li><p><b> Usual Way </b><br />
funtion2(function1(dataset,arg1),arg2)</p></li>
<li><p><b> Using Pipes </b><br />
dataset %&gt;% function1(arg1) %&gt;% function2(arg2)</p></li>
</ul>
<p>Note that we can write directly ‘%&gt;%’ by using ‘ctrl + shift + m’</p>
<p>Here is list of function that are commonly used and actions they provide.</p>
<table>
<colgroup>
<col width="33%" />
<col width="66%" />
</colgroup>
<thead>
<tr class="header">
<th>Functions</th>
<th align="right">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>slice</td>
<td align="right">restrict dataset to specific row (see also slice_head, slice_tail, slice_min, slice_max)</td>
</tr>
<tr class="even">
<td>slice_sample</td>
<td align="right">restrict dataset to random row</td>
</tr>
<tr class="odd">
<td>filter</td>
<td align="right">restrict dataset to row that pass a condition</td>
</tr>
<tr class="even">
<td>select</td>
<td align="right">restrict dataset to specifiyed columns</td>
</tr>
<tr class="odd">
<td>rename</td>
<td align="right">change columns names</td>
</tr>
<tr class="even">
<td>arrange</td>
<td align="right">sort dataset with respect to one columns</td>
</tr>
<tr class="odd">
<td>mutate</td>
<td align="right">modify or create a columns that apply a function</td>
</tr>
<tr class="even">
<td>group_by</td>
<td align="right">group data before running calculation</td>
</tr>
<tr class="odd">
<td>ungroup</td>
<td align="right">ungroup data</td>
</tr>
<tr class="even">
<td>summarise</td>
<td align="right">summarise data with respect to the level of agregation (groups)</td>
</tr>
<tr class="odd">
<td>count</td>
<td align="right">count numbers of row in a group</td>
</tr>
<tr class="even">
<td>lead/lag</td>
<td align="right">shift the observations of a variable one notch backwards (for lead) or forwards (for lag)</td>
</tr>
<tr class="odd">
<td>distinct</td>
<td align="right">given a varaiable restrict the dataset to unique value of this variable</td>
</tr>
<tr class="even">
<td>bind_rows/bind_cols</td>
<td align="right">add columns or rows to the dataset</td>
</tr>
<tr class="odd">
<td>left_join</td>
<td align="right">merge datatables with respect to variable(s) (see also full_join, inner_join, anti_join)</td>
</tr>
</tbody>
</table>
<p>starts_with</p>
<ul>
<li><b> Usual Way </b></li>
</ul>
<div class="r">
<pre class="r"><code>
# R


library(tidyverse)
## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──
## ✔ ggplot2 3.3.6     ✔ purrr   0.3.4
## ✔ tibble  3.1.6     ✔ forcats 0.5.2
## ✔ tidyr   1.2.1     
## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ dplyr::filter() masks stats::filter()
## ✖ dplyr::lag()    masks stats::lag()
covid_papers &lt;- read_csv(&quot;data/covid_papers.csv&quot;)
## Rows: 148916 Columns: 19
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: &quot;,&quot;
## chr  (17): _id, pmid, pmcid, doi, title, source, year_pub, month_pub, author...
## dbl   (1): cited
## date  (1): creation
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

covid_papers
## # A tibble: 148,916 × 19
##    `_id`   pmid   pmcid doi     title       source year_pub month_pub creation  
##    &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt;     &lt;date&gt;    
##  1 5f69d6… 32837… PMC7… 10.100… The Pathop… MED    2020     null      2020-08-25
##  2 5f69d6… 32196… PMC7… 10.108… Hypothesis… MED    2020     null      2020-03-21
##  3 5f69d6… 32778… PMC7… 10.101… The outbre… MED    2020     null      2020-08-12
##  4 5f69d6… 32730… PMC7… 10.101… A comparat… MED    2020     null      2020-07-31
##  5 5f69d6… null   null  10.209… Virion Str… PPR    2020     null      2020-08-16
##  6 5f69d6… null   PMC7… null    Interactio… PMC    2020     null      2020-09-13
##  7 5f69d6… 32394… PMC7… 10.100… A global t… MED    2020     null      2020-05-13
##  8 5f69d6… 32257… PMC7… 10.101… COVID-19 i… MED    2020     null      2020-04-08
##  9 5f69d6… 32720… PMC7… 10.100… The kidney… MED    2020     null      2020-07-29
## 10 5f69d6… 32196… PMC7… 10.108… Laboratory… MED    2020     null      2020-03-21
## # … with 148,906 more rows, and 10 more variables: authors_gender &lt;chr&gt;,
## #   journal &lt;chr&gt;, language &lt;chr&gt;, pubmodel &lt;chr&gt;, pubtype &lt;chr&gt;, mesh &lt;chr&gt;,
## #   keywords &lt;chr&gt;, cited &lt;dbl&gt;, has_data &lt;chr&gt;, oa &lt;chr&gt;

#which(is.na(covid_papers),arr.ind = T)
covid_papers = na.omit(covid_papers)

dim(slice(covid_papers,2))
## [1]  1 19
dim(slice_sample(covid_papers,prop = 0.001))
## [1] 148  19

t &lt;- Sys.time()
doi_clean &lt;- filter(covid_papers,doi != &#39;null&#39;)
Sys.time()-t
## Time difference of 0.03906393 secs</code></pre>
<p><b> Using Pipes </b></p>
<pre class="r"><code># R

dim(covid_papers %&gt;% slice(2))
## [1]  1 19
dim(covid_papers %&gt;% slice_sample(prop = 0.001))
## [1] 148  19

t = Sys.time()
doi_clean &lt;- covid_papers %&gt;% filter(doi != &#39;null&#39;)
Sys.time() - t
## Time difference of 0.03341889 secs

t = Sys.time()
doi_clean &lt;- covid_papers[which(covid_papers$doi != &#39;null&#39;),]
Sys.time() - t
## Time difference of 0.02872062 secs</code></pre>
</div>
</div>
<div id="select-columns" class="section level3" number="1.1.2">
<h3><span class="header-section-number">1.1.2</span> Select columns</h3>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles
cp_tibble &lt;-  as_tibble(covid_papers)

dim(cp_tibble[[4]]) # returns a vector
## NULL
dim(cp_tibble[4])# returns a tibble
## [1] 148913      1

dim(select(cp_tibble, doi)) # returns a tibble
## [1] 148913      1
dim(pull(cp_tibble, doi, name = title))   # returns a (named) vector
## NULL
dim(cp_tibble[, &quot;doi&quot;])        # returns a tibble
## [1] 148913      1
dim(cp_tibble[[&quot;doi&quot;]])        # returns a vector
## NULL

dim(select(cp_tibble, doi, creation, title))
## [1] 148913      3
dim(select(cp_tibble, doi:title)) # select columns between doi and title
## [1] 148913      2

dim(select(cp_tibble, -doi, -creation))
## [1] 148913     17

cols &lt;- c(&quot;doi&quot;, &quot;creation&quot;)
dim(select(cp_tibble, !!cols)) # unquoting
## [1] 148913      2
dim(select(cp_tibble, -!!cols))
## [1] 148913     17</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.tablee
library(data.table)
## 
## Attaching package: &#39;data.table&#39;
## The following object is masked from &#39;package:purrr&#39;:
## 
##     transpose
## The following objects are masked from &#39;package:dplyr&#39;:
## 
##     between, first, last
cp_datatable = as.data.table(covid_papers)

dim(cp_datatable[[4]]) # returns a vector
## NULL
dim(cp_datatable[, 4])  # returns a data.table
## [1] 148913      1

dim(cp_datatable[, list(doi)]) # returns a data.table
## [1] 148913      1
dim(cp_datatable[, .(doi)])    # returns a data.table
## [1] 148913      1
# . is an alias for list

dim(cp_datatable[, &quot;doi&quot;])     # returns a data.table
## [1] 148913      1
dim(cp_datatable[, doi])       # returns a vector
## NULL
dim(cp_datatable[[&quot;doi&quot;]])     # returns a vector
## NULL

dim(cp_datatable[, .(doi, creation, title)])
## [1] 148913      3
dim(cp_datatable[, list(doi, creation, title)])
## [1] 148913      3
dim(cp_datatable[, doi:title]) # select columns between doi and title
## [1] 148913      2

dim(cp_datatable[, !c(&quot;doi&quot;, &quot;creation&quot;)])
## [1] 148913     17

cols &lt;- c(&quot;doi&quot;, &quot;creation&quot;)
dim(cp_datatable[, ..cols]) # .. prefix means &#39;one-level up&#39;
## [1] 148913      2
dim(cp_datatable[, !..cols]) # or cp_datatable[, -..cols]
## [1] 148913     17</code></pre>
</div>
</div>
</div>
<ul>
<li>using regular expression</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles
colnames(cp_tibble)[1:3] &lt;- paste0(&#39;V&#39;,c(1:3))

select(cp_tibble, num_range(&quot;V&quot;, 1:2))
select(cp_tibble, title, everything()) # reorder columns
select(cp_tibble, contains(&quot;V&quot;))
select(cp_tibble, ends_with(&quot;3&quot;))
select(cp_tibble, matches(&quot;.2&quot;))
select(cp_tibble, one_of(c(&quot;V1&quot;, &quot;X&quot;)))
## Warning: Unknown columns: `X`
select(cp_tibble, -starts_with(&quot;doi&quot;))</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.tablee
colnames(cp_datatable)[1:3] &lt;- paste0(&#39;V&#39;,c(1:3))

cols &lt;- paste0(&quot;V&quot;, 1:2)
cols &lt;- union(&quot;title&quot;, names(cp_datatable))
cols &lt;- grep(&quot;V&quot;,   names(cp_datatable))
cols &lt;- grep(&quot;3$&quot;,  names(cp_datatable))
cols &lt;- grep(&quot;.2&quot;,  names(cp_datatable))
cols &lt;- grep(&quot;^V1|X$&quot;,  names(cp_datatable))
cols &lt;- grep(&quot;^(?!doi)&quot;, names(cp_datatable), perl = TRUE)
cp_datatable[, ..cols]</code></pre>
</div>
</div>
</div>
<ul>
<li>Filtering</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles


cp_tibble[3:4,]
slice(cp_tibble, 3:4) # same

cp_tibble[-(3:7),]
slice(cp_tibble, -(3:7)) # same

dim(filter(cp_tibble, year_pub &gt; 2018))
filter(cp_tibble, title %in% c(&quot;Deep convolutional approaches for the analysis of Covid-19 using chest X-Ray images from portable devices&quot;,
                               &quot;Evaluating the effect of city lock-down on controlling COVID-19 propagation through deep learning and network science models.&quot;))

filter(cp_tibble, year_pub == 2019, title == &quot;Deep convolutional approaches for the analysis of Covid-19 using chest X-Ray images from portable devices&quot;)

dim(distinct(cp_tibble)) # distinct_all(cp_tibble)
dim(distinct(cp_tibble, across(c(V1, title)))) # returns selected cols

dim(tidyr::drop_na(cp_tibble, names(cp_tibble)[1:4]))


dim(filter(cp_tibble, grepl(&quot;deep learning&quot;, title)))
dim(filter(cp_tibble, dplyr::between(year_pub, 2015, 2017)))
## Warning in dplyr::between(year_pub, 2015, 2017): NAs introduced by coercion
dim(filter(cp_tibble, year_pub &gt; 2015 &amp; year_pub &lt; 2017))</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

cp_datatable[3:4,]
cp_datatable[3:4] # same

cp_datatable[!3:7,]
cp_datatable[-(3:7)] # same

cp_datatable[year_pub &gt; 2018]
cp_datatable[title %chin% c(&quot;Deep convolutional approaches for the analysis of Covid-19 using chest X-Ray images from portable devices&quot;,
                               &quot;Evaluating the effect of city lock-down on controlling COVID-19 propagation through deep learning and network science models.&quot;)] # fast %in% for character

cp_datatable[year_pub == 2019 &amp; title == &quot;Deep convolutional approaches for the analysis of Covid-19 using chest X-Ray images from portable devices&quot;]

unique(cp_datatable)
unique(cp_datatable, by = c(&quot;V1&quot;, &quot;title&quot;)) # returns all cols

na.omit(cp_datatable, cols = 1:4)  # fast S3 method with cols argument

cp_datatable[title %like% &quot;deep learning&quot;]
cp_datatable[year_pub %between% c(2015, 2017)]
cp_datatable[data.table::between(year_pub, 2015, 2017, incbounds = FALSE)]</code></pre>
</div>
</div>
</div>
<p>On the other hand, data.table also provides convenience functions to filter rows based on a regular expression or to find values lying in one (or several) interval(s).</p>
<p>Below, we will see that data.table has two optimized mechanisms to filter rows efficiently (keys and indices).</p>
<ul>
<li>Sorting</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles
head(cp_tibble %&gt;% arrange(creation) %&gt;% select(creation))
## # A tibble: 6 × 1
##   creation  
##   &lt;date&gt;    
## 1 1929-01-01
## 2 1933-02-01
## 3 1945-01-01
## 4 1946-12-01
## 5 1951-09-08
## 6 1951-12-01
head(cp_tibble %&gt;% arrange(desc(creation)) %&gt;% select(creation)) 
## # A tibble: 6 × 1
##   creation  
##   &lt;date&gt;    
## 1 2020-09-16
## 2 2020-09-16
## 3 2020-09-16
## 4 2020-09-16
## 5 2020-09-16
## 6 2020-09-16

head(cp_tibble %&gt;% arrange(year_pub, desc(creation)) %&gt;% select(year_pub,creation))
## # A tibble: 6 × 2
##   year_pub creation  
##   &lt;chr&gt;    &lt;date&gt;    
## 1 1820     2018-12-05
## 2 1821     2018-06-23
## 3 1830     2018-06-20
## 4 1832     2018-06-20
## 5 1833     2018-06-20
## 6 1835     2018-11-09</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.tablee

head(cp_datatable[order(creation)][,creation])
head(cp_datatable[order(-creation)][,creation])

head(cp_datatable[order(year_pub, -creation)][,.(year_pub,creation)])</code></pre>
</div>
</div>
</div>
<ul>
<li>Summarise</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles
n_distinct(cp_tibble)
## [1] 148913

cp_tibble %&gt;% summarise(sum(cited)) # returns a tibble
## # A tibble: 1 × 1
##   `sum(cited)`
##          &lt;dbl&gt;
## 1      1241805
cp_tibble %&gt;% summarise(sum_citation = sum(cited)) # returns a tibble
## # A tibble: 1 × 1
##   sum_citation
##          &lt;dbl&gt;
## 1      1241805

summarise(cp_tibble, sum(cited), sd(cited))
## # A tibble: 1 × 2
##   `sum(cited)` `sd(cited)`
##          &lt;dbl&gt;       &lt;dbl&gt;
## 1      1241805        38.8

cp_tibble %&gt;%
  summarise(sum_citation = sum(cited),
            sd_citation = sd(creation))
## # A tibble: 1 × 2
##   sum_citation sd_citation
##          &lt;dbl&gt;       &lt;dbl&gt;
## 1      1241805       2671.

cp_tibble %&gt;%
  slice(1:4) %&gt;%
  summarise(sum(cited))
## # A tibble: 1 × 1
##   `sum(cited)`
##          &lt;dbl&gt;
## 1           61

cp_tibble %&gt;% summarise(dplyr::first(year_pub))
## # A tibble: 1 × 1
##   `dplyr::first(year_pub)`
##   &lt;chr&gt;                   
## 1 2020
cp_tibble %&gt;% summarise(dplyr::last(year_pub))
## # A tibble: 1 × 1
##   `dplyr::last(year_pub)`
##   &lt;chr&gt;                  
## 1 2016
cp_tibble %&gt;% summarise(nth(year_pub, 5))
## # A tibble: 1 × 1
##   `nth(year_pub, 5)`
##   &lt;chr&gt;             
## 1 2020
cp_tibble %&gt;% summarise(n_distinct(language))
## # A tibble: 1 × 1
##   `n_distinct(language)`
##                    &lt;int&gt;
## 1                     31</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.tablee

uniqueN(cp_datatable)
## [1] 148913

cp_datatable[, sum(cited)]    # returns a vector
## [1] 1241805
cp_datatable[, .(sum(cited))] # returns a data.table
##         V1
## 1: 1241805
cp_datatable[, .(sum_citation = sum(cited))] # returns a data.table
##    sum_citation
## 1:      1241805

cp_datatable[, .(sum(cited), sd(cited))]
##         V1      V2
## 1: 1241805 38.8293

cp_datatable[, .(sum_citation = sum(cited),
                 sd_citation  = sd(cited))]
##    sum_citation sd_citation
## 1:      1241805     38.8293

cp_datatable[1:4, sum(cited)]
## [1] 61

cp_datatable[, data.table::first(year_pub)]
## [1] &quot;2020&quot;
cp_datatable[, data.table::last(year_pub)]
## [1] &quot;2016&quot;
cp_datatable[5, year_pub]
## [1] &quot;2020&quot;
cp_datatable[, uniqueN(language)]
## [1] 31</code></pre>
</div>
</div>
</div>
<p>Dplyr helper functions for the summarise() function include first(), last(), n(), nth(), and n_distinct(). The data.table package also includes first(), last(), and uniqueN().</p>
<ul>
<li>Modifiying</li>
</ul>
<p>When it comes to modifying columns, data.table allows for the use of the column assignment symbol := to modify columns by reference without creating a copy. With dplyr, the results must be assigned.</p>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

cp_tibble &lt;- cp_tibble %&gt;% rowwise() %&gt;% mutate(oa = ifelse(oa == &#39;Y&#39;,1,0), log_cited = log(cited + 1))



# Create one column and remove the others
transmute(cp_tibble, title_lower = tolower(title))
## # A tibble: 148,913 × 1
## # Rowwise: 
##    title_lower                                                                  
##    &lt;chr&gt;                                                                        
##  1 the pathophysiology, diagnosis and treatment of corona virus disease 2019 (c…
##  2 hypothesis for potential pathogenesis of sars-cov-2 infection-a review of im…
##  3 the outbreak of the novel severe acute respiratory syndrome coronavirus 2 (s…
##  4 a comparative overview of covid-19, mers and sars: review article.           
##  5 virion structure and mechanism of propagation of coronaviruses including sar…
##  6 interaction of sars-cov-2 and other coronavirus with ace (angiotensin-conver…
##  7 a global treatments for coronaviruses including covid-19.                    
##  8 covid-19 infection: origin, transmission, and characteristics of human coron…
##  9 the kidney, covid-19, and the chemokine network: an intriguing trio.         
## 10 laboratory diagnosis of emerging human coronavirus infections - the state of…
## # … with 148,903 more rows

cp_tibble &lt;- cp_tibble %&gt;% select(-V1, -V2)

cols &lt;- c(&#39;V3&#39;,&#39;doi&#39;)
cp_tibble &lt;- select(cp_tibble, -one_of(cols))</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.tablee
cp_datatable[, c(&#39;oa&#39;,&#39;log_cited&#39;) := .(ifelse(oa == &#39;Y&#39;,1,0),log(cited+1))]



# Create one column and remove the others
cp_datatable[, .(title_lower = tolower(title))]
##                                                                                                                                                         title_lower
##      1:                                                                       the pathophysiology, diagnosis and treatment of corona virus disease 2019 (covid-19).
##      2:                                  hypothesis for potential pathogenesis of sars-cov-2 infection-a review of immune changes in patients with viral pneumonia.
##      3:                              the outbreak of the novel severe acute respiratory syndrome coronavirus 2 (sars-cov-2): a review of the current global status.
##      4:                                                                                          a comparative overview of covid-19, mers and sars: review article.
##      5: virion structure and mechanism of propagation of coronaviruses including sars-cov 2 (covid -19 ) and some meaningful points for drug or vaccine development
##     ---                                                                                                                                                            
## 148909:                                                                                                               bmt settings, infection and infection control
## 148910:                                                                                       early and acute complications and the principles of hsct nursing care
## 148911:                                                                                                                                            viral infections
## 148912:                                                                                                        international collaboration for global public health
## 148913:                                                                                                                    resource allocation and priority setting

cp_datatable[, c(&#39;V1&#39;, &#39;V2&#39;) := NULL]

cols &lt;- c(&#39;V3&#39;,&#39;doi&#39;)
cp_datatable[, (cols) := NULL] # ! not cp_datatable[, cols := NULL]</code></pre>
</div>
</div>
</div>
<ul>
<li>Grouping by</li>
</ul>
<p>The dplyr::group_by() function and the corresponding by and keyby statements in data.table allow for the manipulation of each group of observations and combining the results. The main difference between by and keyby is that keyby orders the results and creates a key that allows for faster subsetting (cf. the indexing and keys section). Below, we use one or the other arbitrarily.</p>
<p>The group_by() function takes an existing tibble and converts it into a grouped tibble where operations will always be performed “by group”. Using ungroup() removes grouping. With data.table, by is always used on the fly.</p>
<p>Note that it is possible to reorder the arguments in data.table: cp_datatable[i, j, by] &lt;=&gt; cp_datatable[i, by, j]. This is done below to better highlight the similarity with dplyr.</p>
<p>It’s worth noting that group_by() and by in data.table perform the same task of grouping the data by certain variable(s) and keyby is used to enhance the performance of data.table by creating keys on certain columns, also note that you have to use ungroup() function to remove the grouping in dplyr while in data.table you don’t need to do that.</p>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles
cp_tibble &lt;-  as_tibble(covid_papers) %&gt;% filter(pmid!=&#39;null&#39;)

cp_tibble %&gt;%
  group_by(year_pub) %&gt;%
  summarise(nb_language = length(unique(language)))
## # A tibble: 113 × 2
##    year_pub nb_language
##    &lt;chr&gt;          &lt;int&gt;
##  1 1830               1
##  2 1832               1
##  3 1833               1
##  4 1836               1
##  5 1842               1
##  6 1845               1
##  7 1857               1
##  8 1864               1
##  9 1874               1
## 10 1876               1
## # … with 103 more rows

# By several groups
cp_tibble %&gt;%
  group_by(year_pub, source) %&gt;%
  summarise(mean_cited = mean(cited))
## `summarise()` has grouped output by &#39;year_pub&#39;. You can override using the
## `.groups` argument.
## # A tibble: 113 × 3
## # Groups:   year_pub [113]
##    year_pub source mean_cited
##    &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;
##  1 1830     MED             0
##  2 1832     MED             0
##  3 1833     MED             0
##  4 1836     MED             0
##  5 1842     MED             0
##  6 1845     MED             0
##  7 1857     MED             0
##  8 1864     MED             0
##  9 1874     MED             0
## 10 1876     MED             0
## # … with 103 more rows

# Assigning column name in by
cp_tibble %&gt;%
  group_by(PY = as.numeric(year_pub)) %&gt;%
  summarise(sum_cited = sum(cited))
## # A tibble: 113 × 2
##       PY sum_cited
##    &lt;dbl&gt;     &lt;dbl&gt;
##  1  1830         0
##  2  1832         0
##  3  1833         0
##  4  1836         0
##  5  1842         0
##  6  1845         0
##  7  1857         0
##  8  1864         0
##  9  1874         0
## 10  1876         0
## # … with 103 more rows

# Using a condition
cp_tibble %&gt;%
  group_by(source == &quot;MED&quot;) %&gt;%
  summarise(mean(cited))
## # A tibble: 1 × 2
##   `source == &quot;MED&quot;` `mean(cited)`
##   &lt;lgl&gt;                     &lt;dbl&gt;
## 1 TRUE                       10.9

# Count number of observations for each group
cp_tibble %&gt;%
  group_by(source) %&gt;%
  tally()
## # A tibble: 1 × 2
##   source      n
##   &lt;chr&gt;   &lt;int&gt;
## 1 MED    113917

cp_tibble %&gt;%
  group_by(source) %&gt;%
  summarise(n())
## # A tibble: 1 × 2
##   source  `n()`
##   &lt;chr&gt;   &lt;int&gt;
## 1 MED    113917

cp_tibble %&gt;%
  group_by(source) %&gt;%
  group_size() # returns a vector
## [1] 113917

# Add a column with number of observations for each group
add_count(cp_tibble, year_pub) %&gt;% select(year_pub,n)
## # A tibble: 113,917 × 2
##    year_pub     n
##    &lt;chr&gt;    &lt;int&gt;
##  1 2020     63760
##  2 2020     63760
##  3 2020     63760
##  4 2020     63760
##  5 2020     63760
##  6 2020     63760
##  7 2020     63760
##  8 2020     63760
##  9 2020     63760
## 10 2020     63760
## # … with 113,907 more rows

dim(cp_tibble %&gt;%
  group_by(year_pub) %&gt;%
  add_tally())
## [1] 113917     20</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

cp_datatable &lt;-  as.data.table(covid_papers)[pmid!=&#39;null&#39;,]

cp_datatable[, .(nb_language = length(unique(language))), by = &quot;year_pub&quot;]
##      year_pub nb_language
##   1:     2020          18
##   2:     2019           8
##   3:     2021           2
##   4:     2018           7
##   5:     2017          10
##  ---                     
## 109:     1833           1
## 110:     1845           1
## 111:     1916           1
## 112:     1885           1
## 113:     1832           1

# By several groups
cp_datatable[, keyby = .(year_pub, source),
     .(mean_cited = mean(cited))]
##      year_pub source mean_cited
##   1:     1830    MED 0.00000000
##   2:     1832    MED 0.00000000
##   3:     1833    MED 0.00000000
##   4:     1836    MED 0.00000000
##   5:     1842    MED 0.00000000
##  ---                           
## 109:     2017    MED 7.67789799
## 110:     2018    MED 5.22422209
## 111:     2019    MED 2.76006529
## 112:     2020    MED 2.28764115
## 113:     2021    MED 0.02105263

# Assigning column name in by
cp_datatable[, keyby = .(PY = as.numeric(year_pub)),
     .(sum_cited = sum(cited))]
##        PY sum_cited
##   1: 1830         0
##   2: 1832         0
##   3: 1833         0
##   4: 1836         0
##   5: 1842         0
##  ---               
## 109: 2017     24838
## 110: 2018     17125
## 111: 2019     10146
## 112: 2020    145860
## 113: 2021         2

# Using a condition in by
cp_datatable[, keyby = source == &quot;MED&quot;,
     mean(cited)]
##    source       V1
## 1:   TRUE 10.88341

# Count number of observations for each group
cp_datatable[, .N, by = source]
##    source      N
## 1:    MED 113917
count(cp_tibble, source)
## # A tibble: 1 × 2
##   source      n
##   &lt;chr&gt;   &lt;int&gt;
## 1 MED    113917

# Add a column with number of observations for each group
dim(cp_datatable[, n := .N, by = source][])
## [1] 113917     20</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="more-complex-manipulation" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> More Complex manipulation</h2>
<ul>
<li>Select specific row by group</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

cp_tibble &lt;- cp_tibble %&gt;% mutate(PY = as.numeric(year_pub),log_cited =log(cited+1))

cp_tibble %&gt;%
  group_by(PY) %&gt;%
  slice(1)
cp_tibble %&gt;%
  group_by(PY) %&gt;%
  slice(1, n())
cp_tibble %&gt;%
  group_by(PY) %&gt;%
  group_map(~ tail(.x, 2))</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

cp_datatable[,c(&#39;PY&#39;,&#39;log_cited&#39;) := .(as.numeric(year_pub),log(cited+1))]


cp_datatable[, .SD[1], by = PY]
cp_datatable[, .SD[c(1, .N)], by = PY]
cp_datatable[, tail(.SD, 2), by = PY]</code></pre>
</div>
</div>
</div>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

cp_tibble %&gt;%
  group_by(PY) %&gt;%
  arrange(cited) %&gt;%
  slice(1)
  </code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

cp_datatable[, .SD[which.min(cited)], by = PY]</code></pre>
</div>
</div>
</div>
<ul>
<li>Group counter</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

cp_tibble %&gt;%
  group_by(PY, language) %&gt;%
  mutate(Grp = cur_group_id())</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

cp_datatable[, Grp := .GRP, by = .(PY,  language)][]
cp_datatable[, Grp := NULL] # delete for consistency</code></pre>
</div>
</div>
</div>
<ul>
<li>Get row number of observation by group</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles
cp_tibble %&gt;%
  group_by(PY) %&gt;%
  mutate(cur_group_rows())
## # A tibble: 113,917 × 22
## # Groups:   PY [113]
##    `_id`   pmid   pmcid doi     title       source year_pub month_pub creation  
##    &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt;     &lt;date&gt;    
##  1 5f69d6… 32837… PMC7… 10.100… The Pathop… MED    2020     null      2020-08-25
##  2 5f69d6… 32196… PMC7… 10.108… Hypothesis… MED    2020     null      2020-03-21
##  3 5f69d6… 32778… PMC7… 10.101… The outbre… MED    2020     null      2020-08-12
##  4 5f69d6… 32730… PMC7… 10.101… A comparat… MED    2020     null      2020-07-31
##  5 5f69d6… 32394… PMC7… 10.100… A global t… MED    2020     null      2020-05-13
##  6 5f69d6… 32257… PMC7… 10.101… COVID-19 i… MED    2020     null      2020-04-08
##  7 5f69d6… 32720… PMC7… 10.100… The kidney… MED    2020     null      2020-07-29
##  8 5f69d6… 32196… PMC7… 10.108… Laboratory… MED    2020     null      2020-03-21
##  9 5f69d6… 32656… PMC7… 10.100… The global… MED    2020     null      2020-07-14
## 10 5f69d6… 32732… PMC7… 10.118… Cyclospori… MED    2020     null      2020-08-01
## # … with 113,907 more rows, and 13 more variables: authors_gender &lt;chr&gt;,
## #   journal &lt;chr&gt;, language &lt;chr&gt;, pubmodel &lt;chr&gt;, pubtype &lt;chr&gt;, mesh &lt;chr&gt;,
## #   keywords &lt;chr&gt;, cited &lt;dbl&gt;, has_data &lt;chr&gt;, oa &lt;chr&gt;, PY &lt;dbl&gt;,
## #   log_cited &lt;dbl&gt;, cur_group_rows() &lt;int&gt;
#cp_tibble %&gt;%
#  group_by(PY) %&gt;%
#  group_data() %&gt;%
#  tidyr::unnest(.rows)
cp_tibble %&gt;%
  group_by(PY) %&gt;%
  summarize(cur_group_rows()[1])
## # A tibble: 113 × 2
##       PY `cur_group_rows()[1]`
##    &lt;dbl&gt;                 &lt;int&gt;
##  1  1830                113846
##  2  1832                113890
##  3  1833                113879
##  4  1836                113827
##  5  1842                113769
##  6  1845                113882
##  7  1857                113803
##  8  1864                113838
##  9  1874                113544
## 10  1876                113787
## # … with 103 more rows
cp_tibble %&gt;%
  group_by(PY) %&gt;%
  summarize(cur_group_rows()[c(1, n())])
## `summarise()` has grouped output by &#39;PY&#39;. You can override using the `.groups`
## argument.
## # A tibble: 226 × 2
## # Groups:   PY [113]
##       PY `cur_group_rows()[c(1, n())]`
##    &lt;dbl&gt;                         &lt;int&gt;
##  1  1830                        113846
##  2  1830                        113846
##  3  1832                        113890
##  4  1832                        113890
##  5  1833                        113879
##  6  1833                        113879
##  7  1836                        113827
##  8  1836                        113888
##  9  1842                        113769
## 10  1842                        113885
## # … with 216 more rows</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

cp_datatable[, .I, by = PY] # returns a data.table
##           PY      I
##      1: 2020      1
##      2: 2020      2
##      3: 2020      3
##      4: 2020      4
##      5: 2020      5
##     ---            
## 113913: 1833 113879
## 113914: 1845 113882
## 113915: 1916 113883
## 113916: 1885 113889
## 113917: 1832 113890
cp_datatable[, .I[1], by = PY]
##        PY     V1
##   1: 2020      1
##   2: 2019   1814
##   3: 2021   2351
##   4: 2018  14295
##   5: 2017  19268
##  ---            
## 109: 1833 113879
## 110: 1845 113882
## 111: 1916 113883
## 112: 1885 113889
## 113: 1832 113890
cp_datatable[, .I[c(1, .N)], by = PY]
##        PY     V1
##   1: 2020      1
##   2: 2020 113896
##   3: 2019   1814
##   4: 2019 113915
##   5: 2021   2351
##  ---            
## 222: 1916 113883
## 223: 1885 113889
## 224: 1885 113889
## 225: 1832 113890
## 226: 1832 113890</code></pre>
</div>
</div>
</div>
<ul>
<li>Handle list-columns by group</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

cp_tibble %&gt;%
  group_by(PY) %&gt;%
  summarise(list(cited))
## # A tibble: 113 × 2
##       PY `list(cited)`
##    &lt;dbl&gt; &lt;list&gt;       
##  1  1830 &lt;dbl [1]&gt;    
##  2  1832 &lt;dbl [1]&gt;    
##  3  1833 &lt;dbl [1]&gt;    
##  4  1836 &lt;dbl [3]&gt;    
##  5  1842 &lt;dbl [2]&gt;    
##  6  1845 &lt;dbl [1]&gt;    
##  7  1857 &lt;dbl [1]&gt;    
##  8  1864 &lt;dbl [1]&gt;    
##  9  1874 &lt;dbl [2]&gt;    
## 10  1876 &lt;dbl [1]&gt;    
## # … with 103 more rows

cp_tibble %&gt;%
  group_by(PY) %&gt;%
  group_nest()
## # A tibble: 113 × 2
##       PY                data
##    &lt;dbl&gt; &lt;list&lt;tibble[,20]&gt;&gt;
##  1  1830            [1 × 20]
##  2  1832            [1 × 20]
##  3  1833            [1 × 20]
##  4  1836            [3 × 20]
##  5  1842            [2 × 20]
##  6  1845            [1 × 20]
##  7  1857            [1 × 20]
##  8  1864            [1 × 20]
##  9  1874            [2 × 20]
## 10  1876            [1 × 20]
## # … with 103 more rows</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

cp_datatable[, .(.(cited)),  by = PY]  # return V1 as a list
##        PY                          V1
##   1: 2020        0,61, 0, 0, 1,79,...
##   2: 2019   0, 12,  5,  0,363,  0,...
##   3: 2021             0,0,0,0,0,1,...
##   4: 2018   3, 49, 11, 27, 60,123,...
##   5: 2017       27, 6, 2,22,10,11,...
##  ---                                 
## 109: 1833                           0
## 110: 1845                           0
## 111: 1916                           0
## 112: 1885                           0
## 113: 1832                           0
cp_datatable[, .(.(.SD)), by = PY] # subsets of the data
##        PY                     V1
##   1: 2020 &lt;data.table[63760x21]&gt;
##   2: 2019  &lt;data.table[3676x21]&gt;
##   3: 2021    &lt;data.table[95x21]&gt;
##   4: 2018  &lt;data.table[3278x21]&gt;
##   5: 2017  &lt;data.table[3235x21]&gt;
##  ---                            
## 109: 1833     &lt;data.table[1x21]&gt;
## 110: 1845     &lt;data.table[1x21]&gt;
## 111: 1916     &lt;data.table[1x21]&gt;
## 112: 1885     &lt;data.table[1x21]&gt;
## 113: 1832     &lt;data.table[1x21]&gt;</code></pre>
</div>
</div>
</div>
<ul>
<li>Grouping sets (multiple by at once)</li>
</ul>
<div class="row">
<div class="r">
<pre class="r"><code># R using data.table

rollup(cp_datatable,
       .(cited_med = median(cited)),
       by = c(&quot;pubmodel&quot;, &quot;PY&quot;))
##                      pubmodel   PY cited_med
##   1:       &quot;Print-Electronic&quot; 2020         0
##   2:                  &quot;Print&quot; 2020         0
##   3: &quot;Electronic-eCollection&quot; 2020         0
##   4:             &quot;Electronic&quot; 2020         0
##   5:       &quot;Electronic-Print&quot; 2020         0
##  ---                                        
## 224: &quot;Electronic-eCollection&quot;   NA         0
## 225:             &quot;Electronic&quot;   NA         0
## 226:       &quot;Electronic-Print&quot;   NA         3
## 227:                     null   NA         0
## 228:                     &lt;NA&gt;   NA         0

rollup(cp_datatable,
       .(cited_med = median(cited), .N),
       by = c(&quot;pubmodel&quot;, &quot;PY&quot;),
       id = TRUE)
##      grouping                 pubmodel   PY cited_med      N
##   1:        0       &quot;Print-Electronic&quot; 2020         0  40982
##   2:        0                  &quot;Print&quot; 2020         0  10862
##   3:        0 &quot;Electronic-eCollection&quot; 2020         0   4090
##   4:        0             &quot;Electronic&quot; 2020         0   7362
##   5:        0       &quot;Electronic-Print&quot; 2020         0    456
##  ---                                                        
## 224:        1 &quot;Electronic-eCollection&quot;   NA         0   6981
## 225:        1             &quot;Electronic&quot;   NA         0  11932
## 226:        1       &quot;Electronic-Print&quot;   NA         3    964
## 227:        1                     null   NA         0     32
## 228:        3                     &lt;NA&gt;   NA         0 113917

cube(cp_datatable,
     .(cited_med = median(cited), .N),
     by = c(&quot;pubmodel&quot;, &quot;PY&quot;),
     id = TRUE)
##      grouping                 pubmodel   PY cited_med      N
##   1:        0       &quot;Print-Electronic&quot; 2020         0  40982
##   2:        0                  &quot;Print&quot; 2020         0  10862
##   3:        0 &quot;Electronic-eCollection&quot; 2020         0   4090
##   4:        0             &quot;Electronic&quot; 2020         0   7362
##   5:        0       &quot;Electronic-Print&quot; 2020         0    456
##  ---                                                        
## 337:        2                     &lt;NA&gt; 1845         0      1
## 338:        2                     &lt;NA&gt; 1916         0      1
## 339:        2                     &lt;NA&gt; 1885         0      1
## 340:        2                     &lt;NA&gt; 1832         0      1
## 341:        3                     &lt;NA&gt;   NA         0 113917

groupingsets(cp_datatable,
             .(cited_med = median(cited), .N),
             by   = c(&quot;pubmodel&quot;, &quot;PY&quot;),
             sets = list(&quot;pubmodel&quot;, c(&quot;pubmodel&quot;, &quot;PY&quot;)),
             id   = TRUE)
##      grouping                 pubmodel   PY cited_med     N
##   1:        1       &quot;Print-Electronic&quot;   NA       0.0 61429
##   2:        1                  &quot;Print&quot;   NA       3.0 32579
##   3:        1 &quot;Electronic-eCollection&quot;   NA       0.0  6981
##   4:        1             &quot;Electronic&quot;   NA       0.0 11932
##   5:        1       &quot;Electronic-Print&quot;   NA       3.0   964
##  ---                                                       
## 223:        0                     null 2004       0.0     1
## 224:        0                     null 2016       0.0     4
## 225:        0                     null 2017       0.5     2
## 226:        0                     null 2014       0.0     2
## 227:        0                     null 2018       0.0     2</code></pre>
</div>
</div>
<ul>
<li>Using multiple Variables</li>
</ul>
<p>To manipulate multiple columns, dplyr 1.0.0 introduced the across() function, which supersedes the _all, _at, and _if versions of summarise(), mutate(), and transmute(). In data.table, we use the .SD symbol which is a data.table containing the Subset of Data for each group, excluding the column(s) used in the ‘by’ argument. For example, cp_datatable[, .SD] is equivalent to cp_datatable itself. In the expression cp_datatable[, .SD, by = title], .SD contains all the cp_datatable columns (except the title column) for each unique value of the title column. The .SDcols argument allows to select specific columns to include in the .SD.</p>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

# Summarise several columns
cp_tibble %&gt;% summarise(across(c(PY, cited), mean))
## # A tibble: 1 × 2
##      PY cited
##   &lt;dbl&gt; &lt;dbl&gt;
## 1 2015.  10.9


# Summarise several columns by group
cp_tibble %&gt;%
  group_by(source) %&gt;%
  summarise(across(c(PY, cited), mean))
## # A tibble: 1 × 3
##   source    PY cited
##   &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;
## 1 MED    2015.  10.9

## using patterns (regex)
cp_tibble %&gt;%
  group_by(source) %&gt;%
  summarise(across(ends_with(&#39;cited&#39;), mean))
## # A tibble: 1 × 3
##   source cited log_cited
##   &lt;chr&gt;  &lt;dbl&gt;     &lt;dbl&gt;
## 1 MED     10.9      1.10

# Summarise with more than one function by group
cp_tibble %&gt;%
  group_by(source) %&gt;%
  summarise(across(c(PY, cited),
                   list(median = median, mean = mean)))
## # A tibble: 1 × 5
##   source PY_median PY_mean cited_median cited_mean
##   &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt;        &lt;dbl&gt;      &lt;dbl&gt;
## 1 MED         2020   2015.            0       10.9

# Summarise using a condition
cp_tibble %&gt;%
  summarise(across(where(is.numeric),
                   mean))
## # A tibble: 1 × 3
##   cited    PY log_cited
##   &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;
## 1  10.9 2015.      1.10

cp_tibble  %&gt;%
  group_by(source) %&gt;%
  summarise(across(where(~ is.numeric(.x) &amp;&amp; median(.x)&gt;0), 
                        median))
## # A tibble: 1 × 2
##   source    PY
##   &lt;chr&gt;  &lt;dbl&gt;
## 1 MED     2020</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.tablee


# Summarise several columns
cp_datatable[, lapply(.SD, mean),
     .SDcols = c(&#39;PY&#39;, &#39;cited&#39;)]
##         PY    cited
## 1: 2015.18 10.88341

# Summarise several columns by group
cp_datatable[, by = source,
     lapply(.SD, mean),
     .SDcols = c(&#39;PY&#39;, &#39;cited&#39;)]
##    source      PY    cited
## 1:    MED 2015.18 10.88341
## using patterns (regex)

cp_datatable[, by = source,
     lapply(.SD, mean),
     .SDcols = patterns(&quot;cited&quot;)]
##    source    cited log_cited
## 1:    MED 10.88341  1.103266


# Summarise with more than one function by group
cp_datatable[, by = source,
     c(lapply(.SD, median),
       lapply(.SD, mean)),
     .SDcols = c(&#39;PY&#39;, &#39;cited&#39;)]
##    source   PY cited      PY    cited
## 1:    MED 2020     0 2015.18 10.88341


# Summarise using a condition
cp_datatable[, sapply(cp_datatable, is.numeric),with = FALSE][,lapply(.SD, mean)]
##       cited      n      PY log_cited
## 1: 10.88341 113917 2015.18  1.103266

fun &lt;- function(x) {is.numeric(x) &amp;&amp; median(x)&gt;0}

cp_datatable[, sapply(cp_datatable, FUN = fun),with = FALSE][,lapply(.SD, mean)]
##         n      PY
## 1: 113917 2015.18</code></pre>
</div>
</div>
</div>
<ul>
<li>Modify Multiples Variables</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code>
tobinary = function(x){ifelse(x==&#39;Y&#39;,1,0)}

# Modify several columns (dropping the others)
head(cp_tibble %&gt;% transmute(across(c(has_data, oa),
                 tobinary)))
## # A tibble: 6 × 2
##   has_data    oa
##      &lt;dbl&gt; &lt;dbl&gt;
## 1        0     1
## 2        0     1
## 3        0     1
## 4        0     1
## 5        0     1
## 6        0     1


# Modify several columns (keeping the others)
cp_tibble &lt;- cp_tibble %&gt;%
  mutate(across(all_of(c(&#39;pubtype&#39;,&#39;mesh&#39;)),
                 ~ tolower(str_replace_all(.x,&#39;-&#39;,&#39;&#39;))))

# Modify columns using a condition

t = Sys.time()
cp_tibble &lt;- cp_tibble %&gt;%
  mutate(across(where(is.character),
         toupper))
Sys.time() - t
## Time difference of 4.026845 secs</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># Modify several columns (dropping the others)
head(cp_datatable[, lapply(.SD, tobinary),
     .SDcols = c(&#39;has_data&#39;, &#39;oa&#39;)])
##    has_data oa
## 1:        0  1
## 2:        0  1
## 3:        0  1
## 4:        0  1
## 5:        0  1
## 6:        0  1


# Modify several columns (keeping the others)
cp_datatable[, c(&#39;pubtype&#39;,&#39;mesh&#39;) := lapply(.SD, function(x){tolower(str_replace_all(x,&#39;-&#39;,&#39;&#39;))}),#cols &lt;- setdiff(names(cp_datatable), &quot;title&quot;)
     .SDcols = c(&#39;pubtype&#39;,&#39;mesh&#39;) ]

# Modify columns using a condition 
t = Sys.time()
for(j in  which(sapply(cp_datatable, class)==&#39;character&#39;)){set(cp_datatable, i=NULL, j=j, value=toupper(cp_datatable[[j]]))}
Sys.time() - t 
## Time difference of 3.211064 secs</code></pre>
</div>
</div>
</div>
<p>The use of cp_datatable[,j] in data.table is very flexible, as it allows for the passing of complex expressions in a straightforward way, or the combination of expressions with multiple outputs. This makes it easy to perform complex data manipulation and calculations on large datasets efficiently. The flexibility of the j-expression in data.table is a powerful feature that allows you to perform various data manipulation tasks with a simple and readable syntax.</p>
<ul>
<li>Chain expressions</li>
</ul>
<p>The dplyr workflow relies on the magrittr pipe operator (%&gt;%). The magrittr package can also be used with data.table objects, but data.table has its own chaining system: cp_datatable[][][].</p>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles
# Expression chaining using %&gt;%


head(cp_tibble %&gt;%
  group_by(PY) %&gt;%
  summarise(cited_med = median(cited)) %&gt;%
  arrange(desc(cited_med)))
## # A tibble: 6 × 2
##      PY cited_med
##   &lt;dbl&gt;     &lt;dbl&gt;
## 1  1933      66.5
## 2  1948      34  
## 3  2002      23  
## 4  1956      21  
## 5  2000      21  
## 6  1999      20

head(cp_tibble %&gt;%
  group_by(PY) %&gt;%
  summarise(cited_med = median(cited)) %&gt;%
  filter(cited_med &gt; 10))
## # A tibble: 6 × 2
##      PY cited_med
##   &lt;dbl&gt;     &lt;dbl&gt;
## 1  1933      66.5
## 2  1942      14  
## 3  1948      34  
## 4  1956      21  
## 5  1964      13.5
## 6  1965      14</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.tablee
# Expression chaining using cp_datatable[][] (recommended)

head(cp_datatable[, by = PY, 
     .(cited_med = median(cited))][order(-cited_med)])
##      PY cited_med
## 1: 1933      66.5
## 2: 1948      34.0
## 3: 2002      23.0
## 4: 2000      21.0
## 5: 1956      21.0
## 6: 1999      20.0

head(cp_datatable[, by = PY, 
      .(cited_med = median(cited))][cited_med &gt; 10])
##      PY cited_med
## 1: 2012        13
## 2: 2009        13
## 3: 2010        14
## 4: 2011        12
## 5: 2008        15
## 6: 2007        14</code></pre>
</div>
</div>
</div>
<ul>
<li>More complex expression</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

head(cp_tibble %&gt;%
  mutate(is_en = ifelse(language ==&#39;ENG&#39;,1,0),
         oa_int = ifelse(oa ==&#39;Y&#39;,1,0)) %&gt;%
  group_by(year_pub)  %&gt;% 
  summarize(share_en = sum(is_en)/n(),
            share_en_oa = sum(is_en*oa_int)/n()) %&gt;% 
  arrange(desc(year_pub)))
## # A tibble: 6 × 3
##   year_pub share_en share_en_oa
##   &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;
## 1 2021        0.989       0.884
## 2 2020        0.956       0.685
## 3 2019        0.989       0.867
## 4 2018        0.985       0.829
## 5 2017        0.985       0.817
## 6 2016        0.978       0.791</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.tablee

head(cp_datatable[,c(&#39;is_en&#39;,&#39;oa_int&#39;) := .(ifelse(language ==&#39;ENG&#39;,1,0),
                                       ifelse(oa ==&#39;Y&#39;,1,0))][
                                         ,by = year_pub,.(share_en = sum(is_en)/.N,
                                                          share_en_oa = sum(is_en*oa_int)/.N)])
##    year_pub  share_en share_en_oa
## 1:     2020 0.9555364   0.6848808
## 2:     2019 0.9893906   0.8669750
## 3:     2021 0.9894737   0.8842105
## 4:     2018 0.9853569   0.8288591
## 5:     2017 0.9851623   0.8173107
## 6:     2016 0.9775491   0.7907702
# Use multiple expressions (with cp_datatable[,{j}])
head(cp_datatable[, {is_en = ifelse(language ==&#39;ENG&#39;,1,0) 
                en_oa = is_en*oa_int
                .(pmid,en_oa = ifelse(en_oa == 1, &#39;Y&#39;,&#39;N&#39;)) # last list returned as a data.table
                }])
##        pmid en_oa
## 1: 32837036     Y
## 2: 32196410     Y
## 3: 32778421     Y
## 4: 32730205     Y
## 5: 32394467     Y
## 6: 32257431     Y</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="reshape-data" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Reshape data</h1>
<p>When you have a variable with multiple categories that are stored in one cell, such as the ‘pubtype’ variable in our dataset, you may want to create separate columns for each category. The opposite is also possible, where you have several columns with values that you want to transform into two columns: one with the factor and the other with the values.</p>
<p>To clean this variable and separate the string in each cell, you can use the tidyr package in R. The separate() function allows you to split a single column into multiple columns based on a delimiter. Additionally, the spread() function can be used to transform wide format data into long format data. This can be used to create separate rows for each pubtype.</p>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles
cp_tibble[1,&#39;pubtype&#39;]
## # A tibble: 1 × 1
##   pubtype                                                              
##   &lt;chr&gt;                                                                
## 1 &quot;{\&quot;PUBTYPE\&quot;: [\&quot;REVIEWARTICLE\&quot;, \&quot;REVIEW\&quot;, \&quot;JOURNAL ARTICLE\&quot;]}&quot;

clean_pubtype &lt;- function(str){
  gsub(&#39;[{]|[}]|PUBTYPE|: |[[]|[]]&#39;,&#39;&#39;,str)
}

clean_pubtype(cp_tibble[1,&#39;pubtype&#39;])
## [1] &quot;\&quot;\&quot;\&quot;REVIEWARTICLE\&quot;, \&quot;REVIEW\&quot;, \&quot;JOURNAL ARTICLE\&quot;&quot;

mcp_tibble &lt;- cp_tibble %&gt;% 
  rowwise() %&gt;%
  mutate(pubtype = clean_pubtype(pubtype)) %&gt;% 
  separate_rows(pubtype,sep = &#39;&quot;, &quot;&#39;) %&gt;% 
  mutate(pubtype = gsub(&#39;[&quot;]&#39;,&#39;&#39;,pubtype))

mcp_tibble &lt;- mcp_tibble %&gt;%
  select(pmid, pubtype) %&gt;%
  group_by(pmid) %&gt;% 
  count(pubtype)

mcp_tibble
## # A tibble: 258,370 × 3
## # Groups:   pmid [113,917]
##    pmid     pubtype                                  n
##    &lt;chr&gt;    &lt;chr&gt;                                &lt;int&gt;
##  1 10022847 JOURNAL ARTICLE                          1
##  2 10022847 RESEARCH SUPPORT, NONU.S. GOV&#39;T          1
##  3 10022847 RESEARCHARTICLE                          1
##  4 10023135 JOURNAL ARTICLE                          1
##  5 10023135 RESEARCH SUPPORT, NONU.S. GOV&#39;T          1
##  6 10023135 RESEARCHARTICLE                          1
##  7 10023767 JOURNAL ARTICLE                          1
##  8 10023767 RESEARCH SUPPORT, NONU.S. GOV&#39;T          1
##  9 10023767 RESEARCH SUPPORT, U.S. GOV&#39;T, P.H.S.     1
## 10 10023767 RESEARCHARTICLE                          1
## # … with 258,360 more rows</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table
mcp_datatable &lt;- cp_datatable[,pubtype :=  clean_pubtype(pubtype)][,lapply(.SD, function(x) unlist(tstrsplit(x, &#39;&quot;, &quot;&#39;))), .SDcols = &quot;pubtype&quot;, by = pmid][,pubtype :=  gsub(&#39;[&quot;]&#39;,&#39;&#39;,pubtype)]

mcp_datatable &lt;- mcp_datatable[, .(count = .N), by = .(pmid,pubtype)]
mcp_datatable
##             pmid         pubtype count
##      1: 32837036   REVIEWARTICLE     1
##      2: 32837036          REVIEW     1
##      3: 32837036 JOURNAL ARTICLE     1
##      4: 32196410   REVIEWARTICLE     1
##      5: 32196410 JOURNAL ARTICLE     1
##     ---                               
## 258366: 32091757          REVIEW     1
## 258367: 28590697  CHAPTERARTICLE     1
## 258368: 28590697          REVIEW     1
## 258369: 28590695  CHAPTERARTICLE     1
## 258370: 28590695          REVIEW     1</code></pre>
</div>
</div>
</div>
<div id="cast-data-from-long-to-wide" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Cast data (from long to wide)</h2>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code>
# R using Tibbles

# see also cast_dtm()
ccp_tibble = tidyr::spread(data  = mcp_tibble,
              key   = &#39;pubtype&#39;,
              value = &#39;n&#39;,
              fill  = 0)

dim(ccp_tibble)
## [1] 113917    116</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

ccp_datatable &lt;- dcast(mcp_datatable, pmid ~ pubtype, value.var = &quot;count&quot; ,fun.aggregate = sum) # aggregate by count
dim(ccp_datatable)
## [1] 113917    116</code></pre>
</div>
</div>
</div>
</div>
<div id="melt-data-from-wide-to-long" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Melt data (from wide to long)</h2>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

mcp_tibble &lt;- ccp_tibble %&gt;% gather(key = Variable,
                                    value = Value,
                                    -pmid)
# same
mcp_tibble &lt;- ccp_tibble %&gt;% pivot_longer(cols = -pmid, names_to = &quot;variable&quot;, values_to = &quot;Value&quot;)</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

mcp_datatable &lt;- melt(ccp_datatable, id.vars = &quot;pmid&quot;,
                      variable.name = &quot;Variable&quot;,
                      value.name    = &quot;Value&quot;)
    </code></pre>
</div>
</div>
</div>
</div>
<div id="split" class="section level2" number="2.3">
<h2><span class="header-section-number">2.3</span> Split</h2>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

group_split(cp_tibble, oa)</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

split(cp_datatable, by = &quot;oa&quot;) # S3 method</code></pre>
</div>
</div>
</div>
</div>
<div id="split-and-transpose-a-vectorcolumn" class="section level2" number="2.4">
<h2><span class="header-section-number">2.4</span> Split and transpose a vector/column</h2>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

vec &lt;- c(&quot;A:a&quot;, &quot;B:b&quot;, &quot;C:c&quot;)
# vector not handled
tidyr::separate(tibble(vec), vec, c(&quot;V1&quot;, &quot;V2&quot;))
## # A tibble: 3 × 2
##   V1    V2   
##   &lt;chr&gt; &lt;chr&gt;
## 1 A     a    
## 2 B     b    
## 3 C     c</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

vec &lt;- c(&quot;A:a&quot;, &quot;B:b&quot;, &quot;C:c&quot;)
tstrsplit(vec, split = &quot;:&quot;, keep = 2L) # works on vector
## [[1]]
## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;
setDT(tstrsplit(vec, split = &quot;:&quot;))[]
##    V1 V2
## 1:  A  a
## 2:  B  b
## 3:  C  c</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="indexing-and-keys" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Indexing and Keys</h1>
<div id="set-keyindex" class="section level2" number="3.1">
<h2><span class="header-section-number">3.1</span> Set key/index</h2>
<p>Row subsetting in dplyr relies on the filter() and slice() functions. In addition to these methods, data.table provides two systems that make row filtering and join operations faster and more convenient: keys (primary ordered index) and indices (automatic secondary indexing).</p>
<p>The main differences between keys and indices are:</p>
<ul>
<li>Keys involve physically reordering the data in memory, while indices store the order as an attribute.</li>
<li>Only one key can be used at a time, but multiple indices can coexist.</li>
<li>Keys are defined explicitly, while indices can be created manually or automatically (when using == or %in%).</li>
<li>Indices are used with the ‘on’ argument, while keys are optional but recommended for better readability.</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

cp_tibble &lt;- arrange(cp_tibble, year_pub) </code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

setkey(cp_datatable, year_pub)
setindex(cp_datatable, year_pub)</code></pre>
</div>
</div>
</div>
<ul>
<li>Select rows</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code>
# R using Tibbles

dim(cp_tibble %&gt;% filter(year_pub == &quot;2010&quot;))
## [1] 2190   21
dim(cp_tibble %&gt;% filter(year_pub %in% c(&quot;2010&quot;, &quot;2020&quot;)))
## [1] 65950    21</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

dim(cp_datatable[&quot;2010&quot;, on = &quot;year_pub&quot;])
## [1] 2190   24
dim(cp_datatable[c(&quot;2010&quot;, &quot;2020&quot;), on = .(year_pub)]) # same as on = &quot;year_pub&quot;
## [1] 65950    24</code></pre>
</div>
</div>
</div>
<ul>
<li>Nomatch</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

cp_tibble %&gt;% filter(year_pub %in% c(&quot;2010&quot;, &quot;2025&quot;))
</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

# (default) returns a row with &quot;D&quot; even if not found
cp_datatable[c(&quot;2010&quot;, &quot;2025&quot;), on = &quot;year_pub&quot;, nomatch = NA]
## no rows for unmatched values
cp_datatable[c(&quot;2010&quot;, &quot;2025&quot;), on = &quot;year_pub&quot;, nomatch = 0]</code></pre>
</div>
</div>
</div>
<ul>
<li>Apply function on matched rows</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

cp_tibble %&gt;%
  filter(year_pub %in% c(&quot;2010&quot;, &quot;2020&quot;)) %&gt;%
  summarize(median = median(cited))</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

cp_datatable[c(&quot;2010&quot;, &quot;2020&quot;), median(cited), on = &quot;year_pub&quot;]</code></pre>
</div>
</div>
</div>
<ul>
<li>Modify matched rows values</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

cp_tibble &lt;- cp_tibble %&gt;%
  mutate(cited_ = base::replace(cited, year_pub == &quot;2010&quot;, 0L)) %&gt;%
  arrange(PY)</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

cp_datatable[&quot;2010&quot;, cited_ := 0, on = &quot;year_pub&quot;]</code></pre>
</div>
</div>
</div>
<ul>
<li>Use keys in by</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles
head(cp_tibble %&gt;%
  filter(oa != &#39;Y&#39;) %&gt;%
  group_by(PY) %&gt;%
  summarise(median(cited)))
## # A tibble: 6 × 2
##      PY `median(cited)`
##   &lt;dbl&gt;           &lt;dbl&gt;
## 1  1842               0
## 2  1874               0
## 3  1876               0
## 4  1881               0
## 5  1885               0
## 6  1888               0</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

cp_datatable[!&quot;Y&quot;, mean(cited), on = .(oa), by = .EACHI]
##    oa       V1
## 1:  N 12.93581

head(cp_datatable[oa != &quot;Y&quot;,
   by = PY,
   mean(cited)])
##      PY V1
## 1: 1842  0
## 2: 1874  0
## 3: 1876  0
## 4: 1881  0
## 5: 1885  0
## 6: 1888  0</code></pre>
</div>
</div>
</div>
<ul>
<li>Set multiple keys/indices</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

cp_tibble &lt;-cp_tibble %&gt;%  arrange(PY, cited)</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

setkey(cp_datatable, PY, cited) # or setkeyv(cp_datatable, c(&quot;PY&quot;, &quot;cited&quot;))
setindex(cp_datatable, PY, cited) # setindexv(cp_datatable, c(&quot;PY&quot;, &quot;cited&quot;))</code></pre>
</div>
</div>
</div>
<ul>
<li>Subset using multiple keys/indices</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

dim(filter(cp_tibble, cited == 0, year_pub == &quot;2010&quot;))
## [1] 227  22
dim(filter(cp_tibble, cited == 0, year_pub %in% c(&quot;2010&quot;,&quot;2020&quot;)))
## [1] 50783    22</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

dim(cp_datatable[.(&quot;2010&quot;, 0), on = .(year_pub, cited)])
## [1] 227  25
dim(cp_datatable[.(c(&quot;2010&quot;,&quot;2020&quot;), 0), on = .(year_pub, cited)])
## [1] 50783    25
# using which = TRUE only returns the matching rows indices
dim(cp_datatable[.(c(&quot;2010&quot;,&quot;2020&quot;), 0), on = .(year_pub, cited), which = TRUE])
## NULL</code></pre>
</div>
</div>
</div>
<ul>
<li>Remove keys/indices</li>
</ul>
<div class="r">
<pre class="r"><code># R using data.table

setkey(cp_datatable, NULL)
setindex(cp_datatable, NULL)</code></pre>
</div>
</div>
<div id="set-modifications" class="section level2" number="3.2">
<h2><span class="header-section-number">3.2</span> set*() modifications</h2>
<p>In data.table, the set<em>() functions such as set(), setcol() and setnames() modify objects by reference, which makes these operations fast and memory-efficient. However, if this is not the desired behavior, users can use the copy() function to create a new object. In contrast, the corresponding expressions in dplyr will be less memory-efficient as it creates a new object each time an operation is performed. It’s important to note that data.table’s way of modifying in place is very efficient in terms of time and memory usage when working with large datasets, but it can cause problems if you don’t want to modify your original data. Therefore, it’s recommended to use copy() or make a copy of the data.table before applying set</em>() functions.</p>
<ul>
<li>Replace values</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

cp_tibble[1, 2] &lt;- NA
head(cp_tibble[,2])
## # A tibble: 6 × 1
##   pmid    
##   &lt;chr&gt;   
## 1 &lt;NA&gt;    
## 2 29917937
## 3 29918028
## 4 29918489
## 5 29918401
## 6 29918490</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

set(cp_datatable, i = 1L, j = 2L, value = NA)
head(cp_datatable[,2])
##        pmid
## 1:     &lt;NA&gt;
## 2: 29917937
## 3: 29918028
## 4: 29918489
## 5: 29918401
## 6: 29918490</code></pre>
</div>
</div>
</div>
<ul>
<li>Reorder rows</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

cp_tibble &lt;- cp_tibble %&gt;% arrange(PY, desc(cited))</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

setorder(cp_datatable, PY, -cited)
setorderv(cp_datatable, c(&quot;PY&quot;, &quot;cited&quot;), c(1, -1))</code></pre>
</div>
</div>
</div>
<ul>
<li>Modify colnames</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

cp_tibble &lt;- rename(cp_tibble, DOI = doi)</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

setnames(cp_datatable, old = &quot;doi&quot;, new = &quot;DOI&quot;)</code></pre>
</div>
</div>
</div>
<ul>
<li>Reorder columns</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

head(cp_tibble %&gt;% select(PY, cited, DOI))
## # A tibble: 6 × 3
##      PY cited DOI  
##   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;
## 1  1830     0 NULL 
## 2  1832     0 NULL 
## 3  1833     0 NULL 
## 4  1836     0 NULL 
## 5  1836     0 NULL 
## 6  1836     0 NULL</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

setcolorder(cp_datatable, c(&quot;PY&quot;, &quot;cited&quot;, &quot;DOI&quot;))</code></pre>
</div>
</div>
</div>
<ul>
<li>Set operations</li>
</ul>
<div class="row">
<div class="r">
<pre class="r"><code>x &lt;- data.table(c(1, 2, 2, 3, 3))
y &lt;- data.table(c(2, 2, 3, 4, 4))</code></pre>
</div>
</div>
<ul>
<li>Intersection</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

dplyr::intersect(x, y)
##    V1
## 1:  2
## 2:  3</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

fintersect(x, y)
##    V1
## 1:  2
## 2:  3
fintersect(x, y, all = TRUE)
##    V1
## 1:  2
## 2:  2
## 3:  3</code></pre>
</div>
</div>
</div>
<ul>
<li>Difference</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

dplyr::setdiff(x, y)
##    V1
## 1:  1</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

fsetdiff(x, y)
##    V1
## 1:  1
fsetdiff(x, y, all = TRUE)
##    V1
## 1:  1
## 2:  3</code></pre>
</div>
</div>
</div>
<ul>
<li>Union</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

dplyr::union(x, y)
##    V1
## 1:  1
## 2:  2
## 3:  3
## 4:  4
union_all(x, y)
##     V1
##  1:  1
##  2:  2
##  3:  2
##  4:  3
##  5:  3
##  6:  2
##  7:  2
##  8:  3
##  9:  4
## 10:  4</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

funion(x, y)
##    V1
## 1:  1
## 2:  2
## 3:  3
## 4:  4
funion(x, y, all = TRUE)
##     V1
##  1:  1
##  2:  2
##  3:  2
##  4:  3
##  5:  3
##  6:  2
##  7:  2
##  8:  3
##  9:  4
## 10:  4</code></pre>
</div>
</div>
</div>
<ul>
<li>Equality</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

setequal(x, x[order(-V1),])
## [1] TRUE
all_equal(x, x)
## [1] TRUE</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

fsetequal(x, x[order(-V1),])
## [1] TRUE
all.equal(x, x) # S3 method
## [1] TRUE</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="joinbind-data-sets" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Join/Bind data sets</h1>
<div id="join" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Join</h2>
<p>Joining data in data.table can be done using keys, the ad-hoc ‘on’ argument, or the merge.data.table method. The three methods are presented below. As mentioned earlier, the ‘on’ and ‘by’ (in merge) arguments are optional with keyed data.tables, but are recommended to make the code more explicit. In the examples below, the x, y, and z data.tables can also be used with dplyr.</p>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

x &lt;- data.table(Id  = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;C&quot;),
                X1  = c(1L, 3L, 5L, 7L),
                XY  = c(&quot;x2&quot;, &quot;x4&quot;, &quot;x6&quot;, &quot;x8&quot;),
                key = &quot;Id&quot;)

y &lt;- data.table(Id  = c(&quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;D&quot;),
                Y1  = c(1L, 3L, 5L, 7L),
                XY  = c(&quot;y1&quot;, &quot;y3&quot;, &quot;y5&quot;, &quot;y7&quot;),
                key = &quot;Id&quot;)</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table
</code></pre>
</div>
</div>
</div>
<ul>
<li>Join matching rows from y to x</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles


left_join(x, y, by = &quot;Id&quot;)
##    Id X1 XY.x Y1 XY.y
## 1:  A  1   x2  1   y1
## 2:  B  3   x4  3   y3
## 3:  B  3   x4  5   y5
## 4:  C  5   x6 NA &lt;NA&gt;
## 5:  C  7   x8 NA &lt;NA&gt;</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

y[x, on = &quot;Id&quot;]
##    Id Y1   XY X1 i.XY
## 1:  A  1   y1  1   x2
## 2:  B  3   y3  3   x4
## 3:  B  5   y5  3   x4
## 4:  C NA &lt;NA&gt;  5   x6
## 5:  C NA &lt;NA&gt;  7   x8
merge(x, y, all.x = TRUE, by = &quot;Id&quot;)
##    Id X1 XY.x Y1 XY.y
## 1:  A  1   x2  1   y1
## 2:  B  3   x4  3   y3
## 3:  B  3   x4  5   y5
## 4:  C  5   x6 NA &lt;NA&gt;
## 5:  C  7   x8 NA &lt;NA&gt;
y[x] # requires keys
##    Id Y1   XY X1 i.XY
## 1:  A  1   y1  1   x2
## 2:  B  3   y3  3   x4
## 3:  B  5   y5  3   x4
## 4:  C NA &lt;NA&gt;  5   x6
## 5:  C NA &lt;NA&gt;  7   x8</code></pre>
</div>
</div>
</div>
<ul>
<li>Join matching rows from x to y</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

right_join(x, y, by = &quot;Id&quot;)
##    Id X1 XY.x Y1 XY.y
## 1:  A  1   x2  1   y1
## 2:  B  3   x4  3   y3
## 3:  B  3   x4  5   y5
## 4:  D NA &lt;NA&gt;  7   y7</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

x[y, on = &quot;Id&quot;]
##    Id X1   XY Y1 i.XY
## 1:  A  1   x2  1   y1
## 2:  B  3   x4  3   y3
## 3:  B  3   x4  5   y5
## 4:  D NA &lt;NA&gt;  7   y7
merge(x, y, all.y = TRUE, by = &quot;Id&quot;)
##    Id X1 XY.x Y1 XY.y
## 1:  A  1   x2  1   y1
## 2:  B  3   x4  3   y3
## 3:  B  3   x4  5   y5
## 4:  D NA &lt;NA&gt;  7   y7
x[y] # requires keys
##    Id X1   XY Y1 i.XY
## 1:  A  1   x2  1   y1
## 2:  B  3   x4  3   y3
## 3:  B  3   x4  5   y5
## 4:  D NA &lt;NA&gt;  7   y7</code></pre>
</div>
</div>
</div>
<ul>
<li>Join matching rows from both x and y</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

inner_join(x, y, by = &quot;Id&quot;)
##    Id X1 XY.x Y1 XY.y
## 1:  A  1   x2  1   y1
## 2:  B  3   x4  3   y3
## 3:  B  3   x4  5   y5</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

x[y, on = &quot;Id&quot;, nomatch = 0]
##    Id X1 XY Y1 i.XY
## 1:  A  1 x2  1   y1
## 2:  B  3 x4  3   y3
## 3:  B  3 x4  5   y5
merge(x, y)
##    Id X1 XY.x Y1 XY.y
## 1:  A  1   x2  1   y1
## 2:  B  3   x4  3   y3
## 3:  B  3   x4  5   y5
x[y, nomatch = 0] # requires keys
##    Id X1 XY Y1 i.XY
## 1:  A  1 x2  1   y1
## 2:  B  3 x4  3   y3
## 3:  B  3 x4  5   y5</code></pre>
</div>
</div>
</div>
<ul>
<li>Join keeping all the rows</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

full_join(x, y, by = &quot;Id&quot;)
##    Id X1 XY.x Y1 XY.y
## 1:  A  1   x2  1   y1
## 2:  B  3   x4  3   y3
## 3:  B  3   x4  5   y5
## 4:  C  5   x6 NA &lt;NA&gt;
## 5:  C  7   x8 NA &lt;NA&gt;
## 6:  D NA &lt;NA&gt;  7   y7</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

merge(x, y, all = TRUE, by = &quot;Id&quot;)
##    Id X1 XY.x Y1 XY.y
## 1:  A  1   x2  1   y1
## 2:  B  3   x4  3   y3
## 3:  B  3   x4  5   y5
## 4:  C  5   x6 NA &lt;NA&gt;
## 5:  C  7   x8 NA &lt;NA&gt;
## 6:  D NA &lt;NA&gt;  7   y7</code></pre>
</div>
</div>
</div>
<ul>
<li>Return rows from x matching y</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

semi_join(x, y, by = &quot;Id&quot;)
##    Id X1 XY
## 1:  A  1 x2
## 2:  B  3 x4</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

unique(x[y$Id, on = &quot;Id&quot;, nomatch = 0])
##    Id X1 XY
## 1:  A  1 x2
## 2:  B  3 x4
unique(x[y$Id, nomatch = 0]) # requires keys
##    Id X1 XY
## 1:  A  1 x2
## 2:  B  3 x4</code></pre>
</div>
</div>
</div>
<ul>
<li>Return rows from x not matching y</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

anti_join(x, y, by = &quot;Id&quot;)
##    Id X1 XY
## 1:  C  5 x6
## 2:  C  7 x8</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

x[!y, on = &quot;Id&quot;]
##    Id X1 XY
## 1:  C  5 x6
## 2:  C  7 x8
x[!y] # requires keys
##    Id X1 XY
## 1:  C  5 x6
## 2:  C  7 x8</code></pre>
</div>
</div>
</div>
</div>
<div id="bind" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> Bind</h2>
<ul>
<li>Bind rows</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

x &lt;- data.table(1:3)
y &lt;- data.table(4:6)
z &lt;- data.table(7:9, 0L)

bind_rows(x, y)
##    V1
## 1:  1
## 2:  2
## 3:  3
## 4:  4
## 5:  5
## 6:  6
bind_rows(x, z) # always fills
##    V1 V2
## 1:  1 NA
## 2:  2 NA
## 3:  3 NA
## 4:  7  0
## 5:  8  0
## 6:  9  0</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

rbind(x, y)
##    V1
## 1:  1
## 2:  2
## 3:  3
## 4:  4
## 5:  5
## 6:  6
rbind(x, z, fill = TRUE)
##    V1 V2
## 1:  1 NA
## 2:  2 NA
## 3:  3 NA
## 4:  7  0
## 5:  8  0
## 6:  9  0</code></pre>
</div>
</div>
</div>
<ul>
<li>Bind rows using a list</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

bind_rows(list(x, y), .id = &quot;id&quot;)
##    id V1
## 1:  1  1
## 2:  1  2
## 3:  1  3
## 4:  2  4
## 5:  2  5
## 6:  2  6</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

rbindlist(list(x, y), idcol = TRUE)
##    .id V1
## 1:   1  1
## 2:   1  2
## 3:   1  3
## 4:   2  4
## 5:   2  5
## 6:   2  6</code></pre>
</div>
</div>
</div>
<ul>
<li>Bind columns</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

bind_cols(x, y)
## New names:
## • `V1` -&gt; `V1...1`
## • `V1` -&gt; `V1...2`
##    V1...1 V1...2
## 1:      1      4
## 2:      2      5
## 3:      3      6</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

base::cbind(x, y)
##    V1 V1
## 1:  1  4
## 2:  2  5
## 3:  3  6</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="other" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Other</h1>
<div id="leadlag" class="section level2" number="5.1">
<h2><span class="header-section-number">5.1</span> Lead/Lag</h2>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

lag(1:10, n = 1, default = NA)
##  [1] NA  1  2  3  4  5  6  7  8  9
purrr::map(1:2, ~lag(1:10, n = .x))
## [[1]]
##  [1] NA  1  2  3  4  5  6  7  8  9
## 
## [[2]]
##  [1] NA NA  1  2  3  4  5  6  7  8
lead(1:10, n = 1, default = NA)
##  [1]  2  3  4  5  6  7  8  9 10 NA</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

shift(1:10, n = 1,   fill = NA, type = &quot;lag&quot;)
##  [1] NA  1  2  3  4  5  6  7  8  9
shift(1:10, n = 1:2, fill = NA, type = &quot;lag&quot;) # multiple
## [[1]]
##  [1] NA  1  2  3  4  5  6  7  8  9
## 
## [[2]]
##  [1] NA NA  1  2  3  4  5  6  7  8
shift(1:10, n = 1,   fill = NA, type = &quot;lead&quot;)
##  [1]  2  3  4  5  6  7  8  9 10 NA</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="readwrite-data" class="section level1" number="6">
<h1><span class="header-section-number">6</span> Read/Write data</h1>
<div id="standart-format" class="section level2" number="6.1">
<h2><span class="header-section-number">6.1</span> standart format</h2>
<div class="r">
<pre class="r"><code># R
library(tidyverse)

covid_papers &lt;- read_csv(&quot;data/covid_papers.csv&quot;)
## Rows: 148916 Columns: 19
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: &quot;,&quot;
## chr  (17): _id, pmid, pmcid, doi, title, source, year_pub, month_pub, author...
## dbl   (1): cited
## date  (1): creation
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

covid_papers
## # A tibble: 148,916 × 19
##    `_id`   pmid   pmcid doi     title       source year_pub month_pub creation  
##    &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt;     &lt;date&gt;    
##  1 5f69d6… 32837… PMC7… 10.100… The Pathop… MED    2020     null      2020-08-25
##  2 5f69d6… 32196… PMC7… 10.108… Hypothesis… MED    2020     null      2020-03-21
##  3 5f69d6… 32778… PMC7… 10.101… The outbre… MED    2020     null      2020-08-12
##  4 5f69d6… 32730… PMC7… 10.101… A comparat… MED    2020     null      2020-07-31
##  5 5f69d6… null   null  10.209… Virion Str… PPR    2020     null      2020-08-16
##  6 5f69d6… null   PMC7… null    Interactio… PMC    2020     null      2020-09-13
##  7 5f69d6… 32394… PMC7… 10.100… A global t… MED    2020     null      2020-05-13
##  8 5f69d6… 32257… PMC7… 10.101… COVID-19 i… MED    2020     null      2020-04-08
##  9 5f69d6… 32720… PMC7… 10.100… The kidney… MED    2020     null      2020-07-29
## 10 5f69d6… 32196… PMC7… 10.108… Laboratory… MED    2020     null      2020-03-21
## # … with 148,906 more rows, and 10 more variables: authors_gender &lt;chr&gt;,
## #   journal &lt;chr&gt;, language &lt;chr&gt;, pubmodel &lt;chr&gt;, pubtype &lt;chr&gt;, mesh &lt;chr&gt;,
## #   keywords &lt;chr&gt;, cited &lt;dbl&gt;, has_data &lt;chr&gt;, oa &lt;chr&gt;</code></pre>
</div>
<p>Depending on the way string are encoded we may want to precise the type of encoding. (Some well know encoding character format: UTF-8; Unicode; ASCII ..)</p>
we can sepcify this encoding in the read function.
<div class="r">
<pre class="r"><code># R
covid_papers &lt;- read_csv(&quot;data/covid_papers.csv&quot;,locale = locale(encoding = &quot;UTF-8&quot;))</code></pre>
</div>
<p>Other types of data can be import using other libraries I just show you some examples here without enterring into details that may be helpfull sometimes.</p>
<ul>
<li>Excel data</li>
</ul>
<div class="r">
<pre class="r"><code># R
library(readxl)

covid_papers &lt;- read_excel(&quot;data/covid_papers.xls&quot;, sheet = &quot;Feuille1&quot;, range = &quot;A1:Z25&quot;)</code></pre>
</div>
<ul>
<li>SAS, SPSS et Stata data</li>
</ul>
<div class="r">
<pre class="r"><code># R
library(haven)

#SAS data
covid_papers &lt;- read_sas(&quot;data/covid_papers.sas&quot;)
covid_papers &lt;- read_xpt(&quot;data/covid_papers.xpt&quot;)

#SPSS data
covid_papers &lt;- read_sav(&quot;data/covid_papers.sav&quot;)
covid_papers &lt;- read_por(&quot;data/covid_papers.por&quot;)
</code></pre>
</div>
<p>In order to save data in a specific format we just have to change the ‘read’ part of the function name by ‘write’. Here is an example for csv</p>
<div class="r">
<pre class="r"><code># R

write_csv(new_data_set,&quot;data/new_data.csv&quot;)
</code></pre>
</div>
<p>Also R provide a way to store objects in the same file. For this we use RData format, it’s very usefull if a project is written totaly in R because you can save the structure of your objects very easily, you can save all type of objects and load it later.</p>
<div class="r">
<pre class="r"><code># R

save(covid_papers,file= &#39;covid_papers.RData&#39;)
load(&#39;covid_papers.RData&#39;)
</code></pre>
</div>
</div>
<div id="miscellaneous" class="section level2" number="6.2">
<h2><span class="header-section-number">6.2</span> Miscellaneous</h2>
<ul>
<li>Read / Write data</li>
</ul>
<p>fread() and fwrite() are among the most powerful functions of data.table. They are not only incredibly fast (as seen in benchmarks), but they are also extremely robust. The few commands below only touch the surface, and there are many awesome features. For example, fread() accepts http and https URLs directly, as well as operating system commands such as sed and awk output. Make sure to check the documentation.</p>
<p>Here again, fread() and fwrite() are very versatile and can handle different file formats while dplyr delegates file reading and writing to the readr package with several specific functions (csv, tsv, delim, …). This means that dplyr requires the use of different functions for different file formats, whereas fread() and fwrite() can handle multiple file formats with a single function. This makes data.table’s file handling functions more efficient and easier to use.</p>
<ul>
<li>Write data to a csv file</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

readr::write_csv(cp_tibble, &quot;cp_tibble.csv&quot;)</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

fwrite(cp_datatable, &quot;cp_datatable.csv&quot;)</code></pre>
</div>
</div>
</div>
<ul>
<li>Write data to a tab-delimited file</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

readr::write_delim(cp_tibble, &quot;cp_tibble.txt&quot;, delim = &quot;\t&quot;)
</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

fwrite(cp_datatable, &quot;cp_datatable.txt&quot;, sep = &quot;\t&quot;)
</code></pre>
</div>
</div>
</div>
<ul>
<li>Write list-column data to a csv file</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles
</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

fwrite(setDT(list(0, list(1:5))), &quot;cp_datatable2.csv&quot;)
</code></pre>
</div>
</div>
</div>
<ul>
<li>Read a csv / tab-delimited file</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

readr::read_csv(&quot;cp_tibble.csv&quot;)

readr::read_delim(&quot;cp_tibble.txt&quot;, delim = &quot;\t&quot;)
</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

fread(&quot;cp_datatable.csv&quot;)
# fread(&quot;cp_datatable.csv&quot;, verbose = TRUE) # full details
fread(&quot;cp_datatable.txt&quot;, sep = &quot;\t&quot;)
</code></pre>
</div>
</div>
</div>
<ul>
<li>Read a csv file selecting / droping columns</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles
</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

fread(&quot;cp_datatable.csv&quot;, select = c(&quot;pmid&quot;, &quot;year_pub&quot;))
fread(&quot;cp_datatable.csv&quot;, drop = &quot;title&quot;)
</code></pre>
</div>
</div>
</div>
<ul>
<li>Read and rbind several files</li>
</ul>
<div class="row">
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using Tibbles

c(&quot;cp_tibble.csv&quot;, &quot;cp_tibble.csv&quot;) %&gt;%
  purrr::map_dfr(readr::read_csv)</code></pre>
</div>
</div>
<div class="col-md-6">
<div class="r">
<pre class="r"><code># R using data.table

rbindlist(lapply(c(&quot;cp_datatable.csv&quot;, &quot;cp_datatable.csv&quot;), fread))
# c(&quot;cp_datatable.csv&quot;, &quot;cp_datatable.csv&quot;) %&gt;% lapply(fread) %&gt;% rbindlist</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="exercise" class="section level1" number="7">
<h1><span class="header-section-number">7</span> Exercise</h1>
<a href="https://github.com/master-ds2e/M1-Programming/raw/gh-pages/data/data.zip">
<button class="btn btn-danger"><i class="fa fa-save"></i> Download Data</button>
</a>
<p>Using first <code>dplyr</code> and the <code>tidyverse</code>, Use <code>table_1.csv</code>, <code>table_2.csv</code> and <code>loc_cities.csv</code>, we will need information from the three datasets.</p>
<ul>
<li><p>Import datasets</p></li>
<li><p>Remove articles with no pmid and no DOI, and all articles before 1975</p></li>
<li><p>Merge the two datasets, pmid is unique for each paper</p></li>
<li><p>Create a new variable with the number of authors for each paper</p></li>
<li><p>plot distribution for the log(number of authors +1)</p></li>
<li><p>How many papers contains ‘deep learning’ or ‘machine learning’ and ‘neural network’ (also with a ‘s’ for neural networks) in their title ? Create a binary variable to save this information. What is the mean of authors for ML papers and non#ML papers ?</p></li>
<li><p>Transform has_data and oa into binary variable also, what is the share of ML paper that are oa</p></li>
<li><p>Clean up pubtype, for simplicity just get the first type</p></li>
<li><p>What is the pub type with the highest mean/sd of citation for each type of publication ? (use cited and the cleaned pub_type)</p></li>
<li><p>Which are the most representative country by year ? You may want to separate rows for each authors to get all countries involved in the paper, in an authors have multiple affiliations, take the first one. Store it in an other tibble, keep only pmid and authors, get the country for each author from the loc_cities.csv.</p></li>
<li><p>Select the top 25 of countries involved in coronavirus research since 2001, plot the evolution on a bar chart with plot_ly</p></li>
</ul>
<p>Can you redo the exercice using the data.table library?</p>
<p><a href="">solution with dplyr</a></p>
<p>&lt;! – exo_chap_4_tibble.html –&gt;</p>
<p><a href="">solution with data.table</a></p>
<p>&lt;! – exo_chap_4_dt.html –&gt;</p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
