


```{css, echo=FALSE}
#.r-chunk {
#  background-color: lightpink;
#}
#
#.py-chunk {
#  background-color: lightblue;
#}
#toc: true
#    number_sections: true
#    theme: flatly
#    highlight: kate
#    toc_float:
#      collapsed: false
#      smooth_scroll: true
#  
#
#author: "Pierre Pelletier"
#date: "3 septembre 2020"
#output:
#  html_document:
#  toc: true
#  toc_float: true
#  toc_collapsed: true
#  toc_depth: 3
#  number_sections: true
#  theme: lumen
#
#toc: true
#    number_sections: true
#    theme: flatly
#    highlight: kate
#    toc_float:
#      collapsed: false
#      smooth_scroll: true
#
#



```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,error=TRUE,collapse = TRUE)
library(reticulate)

#  md_document:
#    variant: markdown_github
#
#
#<div class = "row">
#<div class = "col-md-6">
#<div class = "python">
#  
#
#</div>
#</div>
#<div class = "col-md-6">
#<div class = "r">  
#  
#  
#</div>
#</div>
#</div>


#<style>
#div.blue pre { background-color:lightblue; }
#div.blue pre.r { background-color:blue; }
#</style>
#
```

<style>
div.python pre { background-color: #fdfcff; }
</style>

<style>
div.r pre { background-color: #fffffc; }
</style>

# Operations

## Arithmetic Operations
Python and R work as classical calculator, using "+", "-", "*" and "/" we can do arithmetic operations in both language.

<div class = "row">
<div class = "col-md-6">
<div class = "python">

```{python , collapse = T}
# Python 

1+2
1-2
1/2
1*2

```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r, collapse = TRUE}
# R

1+2
1-2
1/2
1*2
```

</div>
</div>
</div>

We can also apply exponantiation, Modulo and floor division easily in both language. Note that in R we can writte the exponantiation "^". It is used for exclusive-or (bitwise) in Python.


<div class = "row">
<div class = "col-md-6">
<div class = "python">

```{python,echo = T,collapse = TRUE}
# Python 

2**8 # exponantiation
2^8 == 2**8 # False
8%3 # modulo
8//3 # floor division
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R

2**8 # exponantiation
2^8 == 2**8 # TRUE
8%%3 # modulo
8%/%3 # floor division

```

</div>
</div>
</div>
Operator (R) | Operator (Python) |	Description
-|:-:|-:
+ | + |	Addition
– | – |	Subtraction
* | * |	Multiplication
/ | / |	Division
^ / ** | ** |	Exponent
%% | % |	Modulo
%/% | // |	floor Division

##  Comparison Operators

In order to compare some values we can use comparison operators to investigate in a given value is equal to, not equal, greater than ... etc

Theses operators are the same in both language.

<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 

2==8
2!=8
2<8
2>8
2<=8

```

</div>
</div>
<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R

2==8
2!=8
2<8
2>8
2<=8
```
</div>
</div>
</div>

Operator (R/Python) |	Description
-|-:
\< 	| Less than
\> 	| Greater than
\<= 	| Less than or equal to
\>= 	| Greater than or equal to
== 	| Equal to
!= 	| Not equal to

## Logical operators


<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 
x = [True,True]
y = [True,False]

not x[0]
x and y
x or y
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R

x = c(TRUE,TRUE)
y = c(TRUE,FALSE)

!x[1]
x & y
x && y
x | y
x || y
```
</div>
</div>
</div>

Operator (R)| Operator (Python)|	Description
-|:-:|-:
! | not |	Logical NOT
& | and |	Element-wise logical AND
&& |  |Logical AND
\| |or|	Element-wise logical OR
\|\|  | |	Logical OR

## Membership operators

in and not in are the membership operators in Python. They are used to test whether a value or variable is found in a sequence. In R %in% allows you to use the python in


<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 
x = 'Hello world'
y = {1:'a',2:'b'}

# Output: True
print('H' in x)

# Output: True
print('hello' not in x)

# Output: True
print(1 in y)

# Output: False
print('a' in y)
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R

x = c(TRUE,TRUE)
y = c(TRUE,FALSE)

!x[1]
x & y
x && y
x | y
x || y
```
</div>
</div>
</div>

# Objects & Variables

ref used : https://www.practicaldatascience.org/html/vars_v_objects.html

Variables are used to store data. In Python and R, we do not need to declare a variable before assigning a value to this variable. we can think of a variable as a name to refers to an object. There is a big difference between python and R on the way the computer is storing object and variables that we will see in the end of the section.



## Difference between R and Python

https://learnanalyticshere.wordpress.com/2015/05/14/clash-of-the-titans-r-vs-python/

While Python is a lot praised for being a general-purpose language with an easy-to-understand syntax, R's functionality is developed with statisticians in thoughts, thus giving it field-specific advantages such as excessive features for data visualization.


In R, a variable and an object are the same things, they refers to the same entities. If we assign to a new variable a variable that already exist, it will refers to two different objects.

Things in Python are more conventional, but since some people learned R before Python it's important to notice that variables refers to an objet but they are still two entities.
It means that two variables can refer to a single object. If two variables are pointing the same object, the modification made with one variable will be also available when using the other variable.

In R two variable can refers to the same object, but once one variable is changed, a new space in the memomry is allocated to a new object.

we mostly should never use for loops in R - they're horribly slow because they execute a function call with every iteration. (One should vectorize and use the apply family of functions instead. Weird, I know..) Vectorization is king in R if we want fast code. Assuming we vectorize both our R and Python code (and other factors), we should probably get the same order of magnitude in speed. For data larger than memory (we can specify the limit), R starts to become a bad choice. 



<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 
import numpy as np
only_nb = [1,2,3,4]
np.std(only_nb)
np.std(only_nb,ddof=1)
with_none = [1,2,3,None]
np.std(with_none)
with_char = [1,2,'3',4]
np.std(with_char)

```

</div>
</div>
<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R
only_nb <- c(1,2,3,4)
sd(only_nb)
with_na <- c(1,2,3,NA)
sd(with_na)
with_char <- c(1,2,'3',4)
sd(with_char)

with_char <- c(1,2,'a',4)
sd(with_char)

```
</div>
</div>

See how R do not show any error and directly remove NA to compute the standart deviation and also convert string to numeric if possible. If converting the string to numeric is not feasible, R finally return a NA. This is not an error message but a warning message. 

We need to writte our code carefully since R can do calculation for a while and just return NA without stopping the process which is not the case in Python. 

Also see here that R calulates the standard deviation with N - 1 as the denominator, and numpy with N. To get the same result we need to use 'ddof=1' as argument in std.
</div>

## Textual and numerical variables

In R textual data are called 'character', in Python it is a string, abbreviate as 'str'. " or ' are used when we set a textual variable in both laguage, but we can also set a variable to textual variable if needed.

Numerical variables a decomposed in three types. In Python we'll have integer, float and complex. In R float is called 'double', reffering to double precision floating point. Without entering into details it means that the number have a precision up to 15 decimals. Float can refers to a precision of 7 decimals, however in Python the data-type 'float' has a precision of 15 numbers. They are ways to get more precisions using Numpy for example. 

Finaly we can check easily the data-type of the variable that we are dealing by asking the language with the command 'type' in Python, or 'typeof' in R.

<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 

import sys 
sys.float_info.dig # number of decimals

a = 1
type(a)

b = 1.1
type(b)

c = 1.1+2j
type(c)

d = 'd'
type(d)

# change the type
e = 2
f = str(e)
f
float(f)
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R

a = 1
typeof(a)
a_int = 1L
typeof(a_int)

b = 1.1
typeof(b)

c = 1.1+2i
typeof(c)

d = 'd'
typeof(d)

# change the type
e = 2
f = as.character(e)
f
as.numeric(f)
```
</div>
</div>
</div>

## Other Data-Type (R)
https://www.statmethods.net/input/datatypes.html

There is a lot of datatype in both language that we will discover along the course, for now we will focus only on basic data-type that are directly available without using anyother package or library,in R common data-type are Vector, Matrix, List, Data frame and factor.


### Vectors and Matrices

<div class = "r">

<div class = "row">
<div class = "col-md-6">

```{r}
# R

vec = c(1, 2, 3)
length(which(vec==2)) # count elements of the list which are exactly equal to 2

vec = sort(vec,
           decreasing = TRUE)
vec
# access the element of a list
vec[1]
vec[which(vec==3)]
vec[2:length(vec)]
vec[length(vec):2]
vec[-1] # throwaway value


```

</div>
<div class = "col-md-6">

```{r}
# R

mat = matrix(c(1, 2, 3, 4, 5, 6),3,2)
dim(mat)
mat

length(which(mat==2)) # count elements of the list which are exactly equal to 2

vec = sort(mat,
           decreasing = TRUE)
vec
# access the element of a list
mat[1] # first element
which(mat==3,
      arr.ind = TRUE) # get row and columns for each value that match

mat[2:length(mat)] # gives us a vector
mat[2:dim(mat)[1],]
mat[length(mat):1]

mat[1,-1] # throwaway values


```

</div>
</div>

```{r}
# modify

b = rep(0,3)
vec = c(vec,b)
vec
mat_2 = rbind(vec,vec)
mat_2 
mat_2 = cbind(mat_2,mat_2)
mat_2

t_mat = t(mat) # transposition
t_mat[2,3] = as.character(t_mat[2,3]) # all values turn to character


i_mat = diag(1, 3)
i_mat


```


</div>

### Data frame

A Data frame in R is a matrix which can store different type of data, characters, numerics or factors. Contrary to the matrix it does not have a fixed dimension it means that we can create a column very easily using the operator '$'.

<div class = "r">

```{r,echo=T,collapse = TRUE}
# Python

df = data.frame(chr = letters[1:5], # letters is a vector of letter provided directly in R
                num = seq(1,5,1),
                fac = factor(c(rep('a',3),rep('b',2)))) 
class(df$chr) # automaticaly converted to factor, which can be very inneficient !
df$chr = as.character(df$chr)
class(df$chr)
colnames(df)
df
# access the element of a variable in a df
df$chr[3]
which(df==3,
      arr.ind = TRUE) 

df[1:2] # gives us a df with the first two columns !
df[3:dim(df)[1],]

df[1,-1] # throwaway values

```
```{r,echo = T,collapse = TRUE}
# modify

b = rep(0,3)
df = rbind(df,b) # introduce a new row in the data frame, note that we get a NA in the factor colmun because '0' is not a level
df$new_col = rep(2,6) # we can introduce new colmuns by specifiying the name and set a value


df
t_df = t(df) # transposition convert the df into a matrix
class(t_df)
```
</div>

### Arrays

Arrays is a generalisation of the matrix, it means that we can have a matrix with more than two dimension. we can modify them as we modify a matrix.

<div class = "r">

```{r,echo=T,collapse = TRUE}
# R

arr = array(seq(1,12,1), dim = c(2,2,3)) # create a matrix with 3 dimension
arr
# access the element of a dictionary
arr[1,,]
arr[,1,]
arr[,,1]
```
</div>

### Lists 

A list permits us to assemble an assortment of disconnected objects behind one variable, it is also possible to store objects which can be of different types.


<div class = "r">

```{r,echo=T,collapse = TRUE}
# Python

lst = list(df = df,
           mat = mat,
           arr = arr) # create a matrix with 3 dimension

lst
lst[[1]] # first element of the list, here it is the df
lst[[1]][1,] # first row of first element of the list
```
</div>



## Other Data-Type (Python)

refused : https://thomas-cokelaer.info/tutorials/python/lists.html

In Python the most common are List, Turple, sets, Dictionnary.
Note that for the moment when modifiying a variable we always use '='. Keep in mind that using the '.' can modify the object behind the variable in Python.

### Lists 

Keep in mind that Lists are mutable, as discussed in the Section "Difference between R and Python"

<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python

a = [1, 2, 3]
a.count(2) # count elements of the list which are exactly equal to 2

a.sort(reverse = True)
a
# access the element of a list
a[0]
a.index(3)
a[1:]
a[:1]
a[0:-1]
a[:]

```
```{python,echo = T,collapse = TRUE}
# modify

b = [0, 0, 0]
list(zip(a,b)) # zip will pairs the ellements, it works also with more than 2 element ex: zip(a,b,c)
a.append(b)
a
a[4:5] = ['a','b']
a
a.extend([4, 5, 6])
a
a += [7,8] # works as extend
a
a.insert(2,[1,2])
a
a.remove(b)
a

a = a*2 # replicate the list n times
len(a) # number of elements in the list

```
```{python,echo = T,collapse = TRUE}
# mutable

a = [1,2,3]
b = a
b[0] = 12
a

```
</div>

### Turples

The main difference between Lists and Turples is the fact that Turples is an immutable type of data making it faster to use.

<div class = "python">
```{python,echo=T,collapse = TRUE}
# Python

a = (1, 2, 3)
a.count(2) # count elements of the turple which are exactly equal to 2

a
# access the element of a turple
a[0]
a.index(3)
a[1:]
a[:1]
a[0:-1]
a[:]

```
```{python,echo = T,collapse = TRUE}

# modify
a += (4,5) 
a
a = a*2 # replicate the turple n times
len(a) # number of elements in the turple

```
```{python,echo = T,collapse = TRUE}
# immutable

a = (1,2,3)
b = a
b[0] = 12
a

```
</div>

### Dictionaries

Dictionary refers to a way of storing data that is not sorted. It works with key and value associate with this key.


<div class = "python">
```{python,echo=T,collapse = TRUE}
# Python

a = {'a':1, 'b':2, 'c':3}
# access the element of a dictionary
a.keys()
a['a']
a.values()
a.items()
a.get('a')
a.get('d',4) # set to 4 if the key 'd' is not detected

a.pop('a') # pop will use the corresponding value to the key a and remove the pair (key, value).
a
a.popitem('b')
a
```
```{python,echo = T,collapse = TRUE}
# modify
a['a'] =1 
a.setdefault('d',0) # create new item with a default value

b = {'d':4,'e':5}
a.update(b) # update values from other dict
a
a.clear() # remove all items

```
```{python,echo = T,collapse = TRUE}
# mutable

a = {'a':1, 'b':2, 'c':3}
b = a
b['b'] = [12,14]
a
```

</div>

### Sets

Sets are unordered collection of unique elements. If we give to a set multiple time the same element it will automatically delete dupplicated values.


<div class = "python">
```{python,echo=T,collapse = TRUE}
# Python

a = {1, 2, 3}
a
# access the element of a set

a[0] # since it unordered, we can not access to a given element of a set


```
```{python,echo = T,collapse = TRUE}
# modify
b = {3,4,5}
a.update(b)  # update values from other set
a

```
```{python,echo = T,collapse = TRUE}
# mutable

a = {'a':1, 'b':2, 'c':3}
b = a
b['b'] = [12,14]
a
```

</div>


### Arrays

In order to manipulate arrays in Python we need to use package numpy, this package is very usefull and will be covered in other chapters.

First see that we can make an array usig R by starting from a vector
R represents all arrays in column-major order, which is not the case in python.

<div class = "row">
<div class = "col-md-6">
<div class = "python">

```{python,echo=T,collapse = TRUE}
# Python

import numpy
arr = numpy.array([[1,4],[2,5],[3,6]])
arr

type(arr)

vec = [1,2,3,4,5,6]

arr = numpy.reshape(vec,(3,2))
arr
arr = numpy.reshape(vec,(3,2), order = 'F')
arr
```


</div>
</div>
<div class = "col-md-6">
<div class = "r">
```{r,echo = T,collapse = TRUE}
# R
arr = as.array(rbind(c(1,4),c(2,5),c(3,6)))
arr

vec = c(1,2,3,4,5,6)

arr = array(vec,dim = c(3,2))
arr
```
</div>
</div>
</div>

As ou can see R and Python does not store vector in the same way: R is storing them by column while python does it by row. Using "order = 'F'" alows us to store vecotr into matrix by column.


<div class = "python">
```{python,echo=T,collapse = TRUE}
# Python

# access the element of an array

arr[0] # access directly to the raw 1


```
```{python,echo = T,collapse = TRUE}
# modify
vec = [7,8]
arr = numpy.insert(arr, len(arr),vec,axis = 0)  # update values from other set
arr

```
```{python,echo = T,collapse = TRUE}
# mutable

arr2 = arr
arr2[0] = [12,14]
arr
```

</div>


### Data Frame

Pandas Data Frames are also very common data-type in Python. The package Pandas is also view deeper in following chapters.

<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python

import pandas

df = pandas.DataFrame(arr)
df

type(df)

vec = [1,2,3,4,5,6]

df = pandas.DataFrame({'vec':vec,'vec1':range(2,8)})
df
```

</div>


<div class = "python">
```{python,echo=T,collapse = TRUE}
# Python

# access the element of a Pandas Data Frame

df['vec'] 

```
```{python,echo = T,collapse = TRUE}
# modify
vec2 = range(3,9)
df['vec2'] = vec2 # add values from other vector
a

```
```{python,echo = T,collapse = TRUE}
# mutable

df2 = df
df['vec'][0] = 30
df2
```

</div>


# Control flow

There are two main control flow tools: choices, and loops. 
choices are very useful for establishing rules or conditions. Choices can be used to modify a value according to a certain condition, generally it allows to launch certain actions in specific cases.
The loops when it allows to execute sequentially actions, it can be to interactively modify an object, more generally it allows to launch a procedure several times. we can for example create N similar objects but we can also modify the N lines of an object.


## Choices



<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 

# if, elif, else

n = 12

if n%2 == 0 :  
  print('n is an even number')
  



if n != int(n): 
  print('n is not a integer')
elif  n%2 == 0 :
  print('n is an even number')
else:
  print('n is not an even number')
  
  

  
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R

# if, elif, else

n = 12L

if(n%%2 == 0){  
  print('n is an even number')
}
  



if(!is.integer(n)){ 
  print('n is not a integer')
  } else if(n%%2 == 0){
    print('n is an even number')
    } else {
      print('n is not an even number')
      }


  
```
</div>
</div>
</div>


## Loops

Using for loops, we will iterate over a predefined number of iteration, sometimes we don't know how many steps we need to perform a given task. Imagine that we want to optimize a function, we don't know how many step we need until reaching an optimum but we can set a condition for which we will consider that the algorithm converged. For this kind of exercice we can use 'while' loops, it will iterate until a given condition is satisfied.


<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 

seq = [1,2,None,4,None,6]
total = 0

for val in seq:
  if val is not None:
    total += val
    
total
```

```{python,echo = T,collapse = TRUE}
# Python 
import random

total = 0
while total < 1:
  rnd = random.gauss(mu = 0, sigma = 1)
  if rnd < 0:
    pass
  else:
    total += rnd
  
total

```

</div>
</div>

<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R
seq = c(1,2,NA,4,NA,6)
total = 0

for(val in seq){
  if(!is.na(val)){
    total = total + val
  }
}
    
total
```


```{r,echo = T,collapse = TRUE}
# R

total = 0

while(total < 1){
  rnd = rnorm(n=1, mean = 0, sd = 1)
  if(rnd < 0){
    # in R we can specify nothing instead of specifiying 'pass'
    } else {
    total = total + rnd }
}
  
total
```

</div>
</div>
</div>

## List, Set and Dict comprehensions (Python)

List comprehension is very common and appreciate in the python language features, think of it as a loop for which we will directly store output in a list, set, or dict. we can use it as a filter for exemple.


<div class = "python">
<div class = "row">
<div class = "col-md-6">
```{python,echo=T,collapse = TRUE}
# Python 
# List
import time

lst = [1,2,3,4]

t = time.time() 
results = []
for val in lst:
  if val > 2:
    results.append(val)
time.time()-t

results

t = time.time() 
# this loop their will produce the same output than a using List comprehension.
results = [val for val in lst if val>2]
time.time()-t

results
```
</div>
<div class = "col-md-6">
```{python,echo=T,collapse = TRUE}
# Python 
# Set
import time

st = {1,2,3,4}

t = time.time() 
results = set([])
for val in st:
  if val > 2:
    results.add(val)
time.time()-t

results

t = time.time() 

# this loop their will produce the same output than a using Set comprehension.
results = {val for val in st if val>2}
time.time()-t

results
```

</div>

<div class = "col-md-6">
```{python,echo=T,collapse = TRUE}
# Python 
# Dict
import time

dct = {'a':1,'b':2,'c':3,'d':4}

t = time.time() 
results = dict([])
for val in dct:
  if dct[val] > 2:
    results.update({str(val): dct[val]})
time.time()-t

results

t = time.time() 
# this loop their will produce the same output than a using Dict comprehension.
results = {str(val): dct[val] for val in dct if dct[val]>2}
time.time()-t

results
```

</div>
</div>
</div>










# Functions


Functions are very important in both language, being able to code ourself things are sometimes more efficient that looking for a package and understand it.  
Being able to write our own function gives we more flexibility and a better understanding of what we are actually doing.   Most of the time, this sentence is wrong and the way we are googling things and reading documentation can also have a major role on ability to play with existent code.  
It's important to not reinvent the wheel, while it is important to be able to construct it ourself. Read documentation carefully while using packages, sometimes packages are misleading and we can spend a lot of time understanding how they work. Look at the packages source code when we are not sure of what the function does behind.  
The full power of programming comes with the fact that we can be autonomous by reading, modifying and writing codes and pre-existing codes.



## General Functions 


<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 

seq = [1,2,None,4,None,6]*120

def clean_sum(seq):
  total = 0

  for val in seq:
    if val is not None:
      total += val
  return total
  
t = time.time()
clean_sum(seq =  seq)
time.time() - t


def clean_sum2(seq):
  total = sum(filter(None,seq))#[val for val in seq if val is not None])
  return total
  
t = time.time()
clean_sum2(seq =  seq)
time.time() - t


```

</div>
</div>

<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R
seq = rep(c(1,2,NA,4,NA,6),120)


clean_sum <- function(seq){
  total = 0
  for(val in seq){
    if(!is.na(val)){
      total = total + val
    }
  }
  return(total)
}

t = Sys.time()
clean_sum(seq = seq)
Sys.time() - t



clean_sum2 <- function(seq){
  sum(na.rm(seq))
  return(total)
}

t = Sys.time()
clean_sum(seq = seq)
Sys.time() - t



```


</div>
</div>
</div>


Functions in Python are objects, they can have attributes and methods like objects. The functions can have data variables and even functions written inside of them.  
Suppose we want to apply several transformation to data, we can create multiple functions to do the different task that we want to perform. we can stock functions in list a apply them sequentially very easily.  
Note that we can separate the output into several variables by specifiying the different values before the assignation. we cannot do that in R directly bt the zeallot package can tackle this problem.



<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 

def add_two(nb):
   nb = [i+2 for i in nb]
   return nb
  
def square_nb(nb):
   nb = [i**2 for i in nb]
   return nb

def global_function(nb):
   for function in func_list:
      nb = function(nb)
   return nb

func_list = [add_two,square_nb]

x1, x2 = global_function([2,3])
x1
x2
```

</div>
</div>

<div class = "col-md-6">
<div class = "r">
```{r,echo=T,collapse = TRUE}
# R
library(zeallot)

add_two <- function(nb){
  nb = nb + 2
  return(nb)
}
  
square_nb <- function(nb){
  nb = nb**2
  return(nb)
}

global_function <- function(nb){
  for(func in func_list){
    nb = func(nb)
      }
  return(nb)
}

func_list = c(add_two,square_nb)

c(x1, x2) %<-% global_function(c(2,3))
x1
x2
```


</div>
</div>
</div>



## Python Generators

Generator usage in python is a simple way of creating iterators. The goal of this kind of function is to return an object for which we can iterate over it. The difference in terms of syntax hold in the fact that we will the statement 'yield' instead of 'return'. In comparaison to 'return', using 'yield' will pause the function and the control of that generator will be trasnfered to the object that call this generator.  
Generators are very very usefull when we deal with object taht can be too heavy to store all the information in our RAM.
As a generators is an iterator, it will load in the RAM only the iteration that it is reading, meaning that we can have no size limit if we want to iterate over an object that is to heavy.
This first example is made with a txt file with 1000 rows. We will see how RAM is used behind our machine to understand how it can be relevant to use genetaors. 


<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 
import os
import psutil
import re
process = psutil.Process(os.getpid())

t = time.time()
r1 = process.memory_info().rss 
def read_file_to_lower():
  with open("data/text.txt", "r") as txt:
    txt_list = txt.read().split('\n')
    txt_list_low = [re.sub(' ','',row.lower()) for row in txt_list] # re.sub here is used to modify each ' ' by nothing.
  return txt_list_low

txt_clean = read_file_to_lower()

process.memory_info().rss - r1 # in bytes
time.time() - t

type(txt_clean)

```

</div>
</div>

<div class = "col-md-6">
<div class = "python">

```{python,echo=T,collapse = TRUE}
# Python

process = psutil.Process(os.getpid())

t = time.time()
r1 = process.memory_info().rss 

def read_to_lower():
  with open("data/text.txt", "r") as txt:
    txt_line = txt.readline()
    while txt_line:
      txt_line = txt.readline()
      yield re.sub(' ','',txt_line.lower())


memory_friendly_txt_clean = read_to_lower()
txt_clean = [line_clean for line_clean in memory_friendly_txt_clean]

process.memory_info().rss - r1 # in bytes
time.time() - t


type(memory_friendly_txt_clean)



```

</div>
</div>
</div>


Note how the memory used during the calculation is very different while the time spend does not really change. 

## Error and Exception Handling

Most of the time writing a function is very task specific, but since data are often dirty and incomplete, our given task may not work. It is important to understand why a given function can produce an error. Being sure that this and this case can leads to errors is not so easy, but it's important not to be too flexible to keep. In ths exemples we will see how setting the flexibility of the function can leads to different results that are more or less what we want.

Look before we leap vs Easier to ask for forgiveness than permission.

if we expect that 99 % of the time result will actually contain something iterable, I'd use the try/except approach. It will be faster if exceptions really are exceptional. If result is None more than 50 % of the time, then using if is probably better.
So, whereas an if statement always costs us, it's nearly free to set up a try/except block. But when an Exception actually occurs, the cost is much higher.

<div class = "row">
<div class = "col-md-6">
<div class = "python">
```{python,echo = T,collapse = TRUE}
# Python 
import numpy as np

# Let's create a function that create a dirty dict for which we want to calculate the sd in each cat
def create_dirty_list(None_prop):
  list_ = list()
  for i in range(10000):
    if i<None_prop*10000:
      list_.append([None])
    else:
      values = random.sample(range(1, 1000), random.sample(range(1, 50),1)[0])
      # introduce some character 
      if i%10==0 :
        values = [str(i) for i in values]
      list_.append(values)
  return list_

# let's create a function to return a tuple with the cat and the sd
def calc1(values):
  output = values[random.sample(range(1, len(values)+1),1)[0]-1]/values[random.sample(range(1, len(values)+1),1)[0]-1]
  return output

list_ = create_dirty_list(0.5)
# Store it in a list
results = [calc1(values) for  values in list_]

```

```{python,echo = T,collapse = TRUE}
# The issue seems to be the fact that a key has no values.
# Let's change the function

def calc2(values):
  if not any(value is None for value in values): 
    output = values[random.sample(range(1, len(values)+1),1)[0]-1]/values[random.sample(range(1, len(values)+1),1)[0]-1]
    return output

results = [calc2(values) for values in list_]

```

```{python,echo = T,collapse = TRUE}
# The issue seems to be the fact that a key has no values.
# Let's change the function

def calc3(values):
  if not any(value is None for value in values): 
    if all(isinstance(value,int) for value in values):
      output = values[random.sample(range(1, len(values)+1),1)[0]-1]/values[random.sample(range(1, len(values)+1),1)[0]-1]
      return output 

results = [calc3(values) for values in list_]

```

```{python,echo = T,collapse = TRUE}
# using try

def calc_try(values):
  try:
    output = values[random.sample(range(1, len(values)+1),1)[0]-1]/values[random.sample(range(1, len(values)+1),1)[0]-1]
  except:
    output = None
  return output
    
results = [calc_try(values) for values in list_]
```

 - Compare execution time 

```{python,echo = T,collapse = TRUE}
list_ = create_dirty_list(0.01)
t= time.time()
results = [calc3(values) for values in list_]
time.time()-t
t= time.time()
results = [calc_try(values) for values in list_]
time.time()-t

```

```{python,echo = T,collapse = TRUE}
list_ = create_dirty_list(0.33)
t= time.time()
results = [calc3(values) for values in list_]
time.time()-t
t= time.time()
results = [calc_try(values) for values in list_]
time.time()-t

```

```{python,echo = T,collapse = TRUE}
list_ = create_dirty_list(0.75)
t= time.time()
results = [calc3(values) for values in list_]
time.time()-t
t= time.time()
results = [calc_try(values) for values in list_]
time.time()-t

```

</div>
</div>

<div class = "col-md-6">
<div class = "r">

```{r,warning=F}
# R
# Let's create a function that create a dirty dict for which we want to calculate the sd in each cat
create_dirty_list <- function(None_prop){
  list_ <- list()
  for(i in seq(1,10000,1)){
    if(i<None_prop*10000){
      list_[[i]] <- c(NA)
      } else {
      values <- sample(seq(1,10000,1),round(runif(1,1,50)))
      # introduce some character 
      if(i%%10==0){
        values <- as.character(values)
      list_[[i]] <- values
      }
      }
  }
  return(list_)
  }
# let's create a function to return a tuple with the cat and the sd
calc1 <- function(values){
  output <- values[round(runif(1,1,length(values)))]/values[round(runif(1,1,length(values)))]
  return(output)
}

list_ <- create_dirty_list(0.5)
# Store it in a list
results <- lapply(list_,FUN = calc1)

```

```{r,warning=F}
# The issue seems to be the fact that a key has no values.
# Let's change the function

calc2 <- function(values){
  if(!any(is.na(values))){
    output <- values[round(runif(1,1,length(values)))]/values[round(runif(1,1,length(values)))]
    return(output)
  }
}


results <- lapply(list_,FUN = calc2)
```

```{r,warning=F}
# The issue seems to be the fact that a key has no values.
# Let's change the function

calc3 <- function(values){
  if(!any(is.na(values))){
    if(is.numeric(values)){
      output <- values[round(runif(1,1,length(values)))]/values[round(runif(1,1,length(values)))]
      return(output)
    }
  }
}



results <- lapply(list_,FUN = calc3)

```

```{r,echo = T,warning=F}
# using try

calc_try <- function(values){
  output <- tryCatch(
    {
      values[round(runif(1,1,length(values)))]/values[round(runif(1,1,length(values)))]
    }
    ,error=function(e){
      return(NA)
    })
  return(output)
}
    
results <- lapply(list_,FUN = calc_try)
```

 - Compare execution time

```{r,echo = T,warning=F}
 
list_ <- create_dirty_list(0.01)
t <- Sys.time()
results <- lapply(list_,FUN = calc3)
Sys.time()-t
t <- Sys.time()
results <- lapply(list_,FUN = calc_try)
Sys.time()-t

```

```{r,echo = T,warning=F}
# compare it 
list_ = create_dirty_list(0.33)
t <- Sys.time()
results <- lapply(list_,FUN = calc3)
Sys.time()-t
t <- Sys.time()
results <- lapply(list_,FUN = calc_try)
Sys.time()-t

```

```{r,echo = T,warning=F}
# compare it 
list_ = create_dirty_list(0.75)
t <- Sys.time()
results <- lapply(list_,FUN = calc3)
Sys.time()-t
t <- Sys.time()
results <- lapply(list_,FUN = calc_try)
Sys.time()-t

```
</div>
</div>
</div>


https://www.w3schools.com/python/python_ref_string.asp
https://thomas-cokelaer.info/tutorials/python/strings.html

# Dealing with strings

<div class = "row">
<div class = "col-md-6">
<div class = "python">

```{python , collapse = T}
# Python 
import time
import psutil
import os

time_ = time.ctime(time.time())
time_info = 'Time: '
mem = psutil.virtual_memory().total/1e9
mem_info = '\nRAM (GB): '
cpu = psutil.cpu_count()
cpu_info = '\n# CPU: '
wd = os.getcwd()
wd_info = '\nCurrent working directory: '

infos = time_info+time_+mem_info+str(mem)+cpu_info+str(cpu)+wd_info+wd

print(infos)

```

In R we use cat() to take into account '\n' (new line), Python automatically understand it with print.

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r, collapse = TRUE}
# R
library(benchmarkme)
time_ <- Sys.time()
time_info <- 'Time: '
mem <- get_ram()/1e9
mem_info <- '\nRAM (GB): '
cpu <- get_cpu()$no_of_cores
cpu_info <- '\n# CPUs: '
wd = getwd()
wd_info = '\nCurrent working directory: '

infos <- paste0(time_info,time_,
           mem_info,as.character(mem),
           cpu_info,as.character(cpu),
           wd_info,wd)
print(infos) 

cat(infos) 

```

</div>
</div>
</div>


Here is some information on the computer where this document was compiled. 

The working directory is the path to the folder where we are working, If we read or write on a file without specifiying the exact path (only the name of the file), the program will search for this file in the current working directory.

'\', the backslash character is used to specify special character, tabulation, new lines, backslash or quotes and so on. When dealing with path this may be confusing for the machine. We can specify that the string must be read as it is by using 'r' before the quote.  

Here is a list of escape character that can be usefull

 Escape Sequence | Description 
- | -:
 \\t 	| Insert a tab in the text at this point.
 \\b 	| Insert a backspace in the text at this point.
 \\n 	| Insert a newline in the text at this point.
 \\r 	| Insert a carriage return in the text at this point.
 \\f 	| Insert a formfeed in the text at this point.
 \\' 	| Insert a single quote character in the text at this point.
 \\" 	| Insert a double quote character in the text at this point.
 \\\ 	| Insert a backslash character in the text at this point.   
 
source : https://docs.oracle.com/javase/tutorial/java/data/characters.html
 
<div class = "row">
<div class = "col-md-6">
<div class = "python">


```{python, collapse = T}
# Python 

wd_t = r'C:\Users\mypath\to\myfolder'
wd_t
print(wd_t)
```

- The point of the r'...' notation is for writing raw strings and use different rules for interpreting backslash escape sequences. If we're just getting the value from another variable, there's no need for an r.

- A string in Python is workng as an array, we can easily select pieces of the string with the position of the letters. In R a string is a block that we need to decompose ourself if we want to select a specific letter. The nb of character present in a string will be then the length of the object.
We can modify string in several ways which are listed here : https://www.w3schools.com/python/python_ref_string.asp  
We see here some classical examples 
```{python , collapse = T, error= T}
# Python 

wd_info = 'Current working directory:\n'+os.getcwd()
slc_infos = wd_info[10:20]
len(slc_info)
slc_infos
slc_infos = list(slc_infos)
slc_infos

# immutable
slc_infos[7] = '0'
slc_infos

# count
wd_info.count('s')

# modify the string
wd_info.title()
wd_info.upper()
wd_info.lower()
splt_inf = wd_info.split(': ')
splt_inf
' '.join(splt_inf)

```
- In Python, the % sign lets us produce formatted output. We can also use "{}".format() in order to change automatically values in raw text. Let's rewritte our function.
```{python , collapse = T}
# Python 

def get_infos():
  time_info = 'Time: '+time.ctime(time.time())
  mem_info = '\nRAM (GB): '+str(psutil.virtual_memory().total/1e9)
  cpu_info = '\n# CPUs: '+str(psutil.cpu_count())
  wd_info = '\nCurrent working directory: '+os.getcwd()
  infos = time_info+mem_info+cpu_info+wd_info
  print(infos)


def get_infos_2():
  infos = '''Time: %s 
  RAM (GB): %s
  # CPUs: %s 
  Current working directory: %s'''% (time.ctime(time.time()),
  psutil.virtual_memory().total/1e9,
  psutil.cpu_count(),
  os.getcwd())
  print(infos)
  
def get_infos_3():
  infos = '''Time: {t} 
  RAM (GB): {ram}
  # CPUs: {cpu} 
  Current working directory: {wd}'''.format(t = time.ctime(time.time()),
  ram = psutil.virtual_memory().total/1e9,
  cpu = psutil.cpu_count(),
  wd = os.getcwd())
  print(infos)
  
  

t = time.time()
get_infos()
print(time.time()-t)


t = time.time()
get_infos_2()
print(time.time()-t)

t = time.time()
get_infos_3()
print(time.time()-t)


```
</div>
</div>

<div class = "col-md-6">
<div class = "r">
```{r, collapse = T}
# R 

wd_t = 'C:\\Users\\mypath\\to\\myfolder'
print(wd_t)
cat(wd_t)
```
 - In R they are no way of told R to read literal backslash, we need to double it while writting it. Also we need to split the string before accessing to element of this string.  
The function 'strsplit' is made to work with vector also, it automatically create a list for which each element of this list is the decomposed string.  
That's why we see '[[1]]' after each strsplit function calls. We want to access only the first element because there is only one string in the object submitted to the function.
```{r , collapse = T, error= T}
# R 
library(stringr)
library(tools)

wd_info  <- paste0('Current working directory: ',getwd())
slc_infos <- wd_info[10:20]
slc_infos
slc_infos <- paste(strsplit(wd_info,split = '')[[1]][10:20],collapse = "")

nchar(slc_infos)
slc_infos
slc_infos <- strsplit(slc_infos,split = '')[[1]]
slc_infos

# mutable
slc_infos[7] = '0'

# count
length(which(strspilt(wd_info,split = '')[[1]]=='S'))

# modify the string
toTitleCase(wd_info)
toupper(wd_info)
tolower(wd_info)
```

- We see here howwhen using paste and paste0, with and without the argument collapse, leads to different results. str_c works similarly, this function comes from the very popular stringr library 

```{r , collapse = T}
paste0('a :','1','b :','2','c :','3')
paste('a :','1','b :','2','c :','3')

paste0(c('a :','1','b :','2','c :','3')) # do nothing with a vector
paste(c('a :','1','b :','2','c :','3'),collapse = " ") # safer to use this
str_c(c('a :','1','b :','2','c :','3'),collapse = " ")

paste0(c('a :','b :','c :'),c('1','2','3'))
paste(c('a :','b :','c :'),c('1','2','3'))
paste(c('a :','b :','c :'),c('1','2','3'),collapse = ".")

paste0(c('a :','b :','c :'),c('0'))
paste(c('a :','b :','c :'),c('0'),collapse = "~")
str_c(c('a :~','b :~','c :~'),c('0'))

```


- In R the use of % is also possible for formatting strings. We can directly use sprintf to print the formated string but is also possible to store it for later use. Then we can use cat to print the string containing escape character or we can use writeLines as in 'get_info_2'

```{r , collapse = T}

# R
library(doParallel)

get_infos <- function(){
  time_info = paste0('Time: ',Sys.time())
  mem_info = paste0('\nRAM (GB): ',as.character(get_ram()/1e9))
  cpu_info = paste0('\n# CPUs: ',as.character(detectCores()))
  wd_info = paste0('\nCurrent working directory: ',getwd())
  infos = paste0(time_info,mem_info,cpu_info,wd_info)
  cat(infos)
}


get_infos_2<- function(){
  infos = sprintf('Time: %s 
  RAM (GB): %s
  # CPUs: %s 
  Current working directory: %s',
  Sys.time(),
  get_ram()/1e9,
  detectCores(),
  getwd())
  writeLines(infos) # other way of take into account escape character
}

t = Sys.time()
get_infos()
Sys.time()-t

t = Sys.time()
get_infos_2()
Sys.time()-t


```

</div>
</div>
</div>

# Exercices


