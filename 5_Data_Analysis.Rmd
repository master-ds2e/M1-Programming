<style>
div.python pre { background-color: #fdfcff; }
</style>

<style>
div.r pre { background-color: #fffffc; }
</style>

http://eric.univ-lyon2.fr/~ricco/tanagra/fichiers/fr_Tanagra_R_Python_Data_Perfs.pdf
https://juba.github.io/tidyverse/06-tidyverse.html
http://python-simple.com/python-pandas/panda-intro.php

"It is often said that 80% of data analysis is spent on the process of cleaning and preparing the data (Dasu and Johnson 2003).  Data preparation is not just a first step,  but must berepeated many times over the course of analysis as new problems come to light or new datais collected." [(Wickham, 2014)](https://www.jstatsoft.org/article/view/v059i10).
Data can be store as csv, txt, excel format, etc.. There is a lot of different ways of storing data as seen in other lessons this semester. here We will focus on using data from txt or csv format for simplicity, csv are just delimited text file with comma.
We need to be able to open and treat data whatever the type of data that we are dealing with, sometimes it's easier to transform data in a way that we are use to work with. Sometimes it's unapropriate and you can corrupt or miss information in the data base, it's important to read documentation if you are in front of a new data formating type. 


# R


The Tidyverse is a collection of differents packages which works together in a common philosophy, the biggest contributor to this collection is named Hadley Wickham. Hadley Wickham did so much for the R community, he published a lot of books  that I highly recommend to read. Check [Wikipedia: Haldey Wickham](https://en.wikipedia.org/wiki/Hadley_Wickham) for his bibliograpy. Here is the list of libraries that are contained in the Tidyverse:
- ggplot2: Visualization
- dplyr: Data manipulation
- tidyr: Data formatting
- purrr: programming
- readr: Data importation
- tibble: Data tables
- forcats: Qualitative variables
- stringr: Strings

The goal of tidyverse is to make easy data analysis by simplifying the data preparation. Tidyverse comes with a new data-type, Tibbles. 

Tibbles can be considered a modern version of data.frame but they differs in some aspects. They do not have rowname and allows users to have colnames with special character (e.g. if colname of x is 'Col 1' then to access to this colnums you can use x$\`Col 1\` to acces to this variables.). It provide a good way also to visualize the data since it directly show data as if you were running the 'head()' function before. It shows you the 10 first rows.

Data.table is also very common when dealing with data and is very fast. Using tibbles can be very time consuming when dealing with large tables.

##  Read/Write data 

<div class = "r">

```{r,echo=T,collapse = TRUE}
# R
library(tidyverse)

covid_papers <- read_csv("data/covid_papers.csv")

covid_papers

```
</div>

Depending on the way string are encoded we may want to precise the type of encoding. (Some well know encoding character format: UTF-8; Unicode; ASCII ..)


we can sepcify this encoding in the read function.
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R
covid_papers <- read_csv("data/covid_papers.csv",locale = locale(encoding = "UTF-8"))
```
</div>
 
Other types of data can be import using other libraries I just show you some examples here without enterring into details that may be helpfull sometimes.

- Excel data

<div class = "r">
```{r,echo=T,collapse = TRUE,eval=F}
# R
library(readxl)

covid_papers <- read_excel("data/covid_papers.xls", sheet = "Feuille1", range = "A1:Z25")
```
</div>

-  SAS, SPSS et Stata data

<div class = "r">

```{r,echo=T,collapse = TRUE,eval=F}
# R
library(haven)

#SAS data
covid_papers <- read_sas("data/covid_papers.sas")
covid_papers <- read_xpt("data/covid_papers.xpt")

#SPSS data
covid_papers <- read_sav("data/covid_papers.sav")
covid_papers <- read_por("data/covid_papers.por")



```
</div>

In order to save data in a specific format we just have to change the 'read' part of the function name by 'write'. Here is an example for csv


<div class = "r">

```{r,echo=T,collapse = TRUE,eval=F}
# R

write_csv(new_data_set,"data/new_data.csv")


```
</div>

## RData

Also R provide a way to store objects in the same file. For this we use RData format, it's very usefull if a project is written totaly in R because you can save the structure of your objects very easily, you can save all type of objects and load it later.
 

<div class = "r">

```{r,echo=T,collapse = TRUE,eval=F}
# R

save(covid_papers,file= 'covid_papers.RData')
load('covid_papers.RData')


```
</div>


## Tibbles and data.tables

https://atrebas.github.io/post/2019-03-03-datatable-dplyr/


### Basic operations

#### Select columns
<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles

DF[[3]] # returns a vector
DF[3]   # returns a tibble

select(DF, V2) # returns a tibble
pull(DF, V2, name = V4)   # returns a (named) vector
DF[, "V2"]        # returns a tibble
DF[["V2"]]        # returns a vector

select(DF, V2, V3, V4)
select(DF, V2:V4) # select columns between V2 and V4

select(DF, -V2, -V3)

cols <- c("V2", "V3")
select(DF, !!cols) # unquoting
select(DF, -!!cols)
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table
library(data.table)

DT[[3]] # returns a vector
DT[, 3]  # returns a data.table

DT[, list(V2)] # returns a data.table
DT[, .(V2)]    # returns a data.table
# . is an alias for list

DT[, "V2"]     # returns a data.table
DT[, V2]       # returns a vector
DT[["V2"]]     # returns a vector

DT[, .(V2, V3, V4)]
DT[, list(V2, V3, V4)]
DT[, V2:V4] # select columns between V2 and V4

DT[, !c("V2", "V3")]

cols <- c("V2", "V3")
DT[, ..cols] # .. prefix means 'one-level up'
DT[, !..cols] # or DT[, -..cols]
```

</div>
</div>
</div>

 - using regular expression
 
<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles

select(DF, num_range("V", 1:2))
select(DF, V4, everything()) # reorder columns
select(DF, contains("V"))
select(DF, ends_with("3"))
select(DF, matches(".2"))
select(DF, one_of(c("V1", "X")))
select(DF, -starts_with("V2"))
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table

cols <- paste0("V", 1:2)
cols <- union("V4", names(DT))
cols <- grep("V",   names(DT))
cols <- grep("3$",  names(DT))
cols <- grep(".2",  names(DT))
cols <- grep("^V1|X$",  names(DT))
cols <- grep("^(?!V2)", names(DT), perl = TRUE)
DT[, ..cols]
```

</div>
</div>
</div>

#### Filtering
<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles
cp_tibble <- as_tibble(covid_papers) 

cp_tibble[3:4,]
slice(cp_tibble, 3:4) # same

cp_tibble[-(3:7),]
slice(cp_tibble, -(3:7)) # same

filter(cp_tibble, V2 > 5)
filter(cp_tibble, V4 %in% c("A", "C"))

filter(cp_tibble, V1 == 1, V4 == "A")

distinct(cp_tibble) # distinct_all(cp_tibble)
distinct(cp_tibble, across(c(V1, V4))) # returns selected cols

tidyr::drop_na(cp_tibble, names(cp_tibble))


slice_sample(cp_tibble, n = 3)      # n random rows
# sample_n(cp_tibble, 3)
slice_sample(cp_tibble, prop = 0.5) # fraction of rows
# sample_frac(cp_tibble, 0.5)
cp_tibble %>% slice_max(V1, n = 1)

filter(cp_tibble, grepl("^B", V4))
filter(cp_tibble, dplyr::between(V2, 3, 5))
filter(cp_tibble, V2 > 3 & V2 < 5)
filter(cp_tibble, V2 >= -1:1 & V2 <= 1:3)
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table
library(data.table)

DT[3:4,]
DT[3:4] # same

DT[!3:7,]
DT[-(3:7)] # same

DT[V2 > 5]
DT[V4 %chin% c("A", "C")] # fast %in% for character

DT[V1 == 1 & V4 == "A"]

unique(DT)
unique(DT, by = c("V1", "V4")) # returns all cols

na.omit(DT, cols = 1:4)  # fast S3 method with cols argument

DT[sample(.N, 3)] # .N = nb of rows in DT
DT[sample(.N, .N / 2)]
DT[frankv(-V1, ties.method = "dense") < 2] 

DT[V4 %like% "^B"]
DT[V2 %between% c(3, 5)]
DT[data.table::between(V2, 3, 5, incbounds = FALSE)]
DT[V2 %inrange% list(-1:1, 1:3)] # see also ?inrange

```

</div>
</div>
</div>

# top_n(DF, 1, V1)
On the other hand, data.table also provides convenience functions to filter rows based on a regular expression or to find values lying in one (or several) interval(s).

Below, we will see that data.table has two optimized mechanisms to filter rows efficiently (keys and indices).

#### Sorting

<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles

arrange(DF, V3)
arrange(DF, desc(V3))

arrange(DF, V1, desc(V2))
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table

DT[order(V3)] 
DT[order(-V3)]

DT[order(V1, -V2)]
```

</div>
</div>
</div>


#### Summarise data


<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles

summarise(DF, sum(V1)) # returns a tibble
summarise(DF, sumV1 = sum(V1)) # returns a tibble

summarise(DF, sum(V1), sd(V3))

DF %>%
  summarise(sumv1 = sum(V1),
            sdv3  = sd(V3))

DF %>%
  slice(1:4) %>%
  summarise(sum(V1))

summarise(DF, dplyr::first(V3))
summarise(DF, dplyr::last(V3))
summarise(DF, nth(V3, 5))
summarise(DF, n_distinct(V4))
n_distinct(DF)
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table

DT[, sum(V1)]    # returns a vector
DT[, .(sum(V1))] # returns a data.table
DT[, .(sumV1 = sum(V1))] # returns a data.table

DT[, .(sum(V1), sd(V3))]

DT[, .(sumv1 = sum(V1),
       sdv3  = sd(V3))]

DT[1:4, sum(V1)]

DT[, data.table::first(V3)]
DT[, data.table::last(V3)]
DT[5, V3]
DT[, uniqueN(V4)]
uniqueN(DT)
```

</div>
</div>
</div>

dplyr helper functions for summarise() (or summarize()) include first(), last(), n(), nth(), and n_distinct(). The data.table package also include first(), last(), and uniqueN().


#### Add/update/delete columns
In the following commands, with data.table, columns are modified by reference using the column assignment symbol := (no copy performed) and the results are returned invisibly. With dplyr, we have to assign the results.


<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles
DF <- DF %>% mutate(V1 = V1^2)
DF

DF <- mutate(DF, v5 = log(V1))


DF <- mutate(DF, v6 = sqrt(V1), v7 = "X")

# Create one column and remove the others
transmute(DF, v8 = V3 + 1)

DF <- select(DF, -v5)

DF <- select(DF, -v6, -v7)

cols <- c("V3")
DF <- select(DF, -one_of(cols))

DF <- mutate(DF, V2 = base::replace(V2, V2 < 4, 0L))
DF
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table
DT[, V1 := V1^2]
DT

DT[, v5 := log(V1)][] # adding [] prints the result


DT[, c("v6", "v7") := .(sqrt(V1), "X")]

DT[, ':='(v6 = sqrt(V1),
          v7 = "X")]     # same, functional form


# Create one column and remove the others
DT[, .(v8 = V3 + 1)]

DT[, v5 := NULL]

DT[, c("v6", "v7") := NULL]

cols <- c("V3")
DT[, (cols) := NULL] # ! not DT[, cols := NULL]

DT[V2 < 4, V2 := 0L]
DT
```

</div>
</div>
</div>



#### Grouping 
by
The dplyr::group_by() function and the corresponding by and keyby statements in data.table allow to run manipulate each group of observations and combine the results. The sole difference between by and keyby is that keyby orders the results and creates a key that will allow faster subsetting (cf. the indexing and keys section). Below, we arbitrary use one or the other.
group_by() takes an existing tibble and converts it into a grouped tibble where operations will always be performed “by group”. Using ungroup() removes grouping. With data.table, by is always used on the fly.
Note that it is possible to reorder the arguments in data.table: DT[i, j, by] <=> DT[i, by, j]. This is done below to better highlight the similarity with dplyr.

<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles

DF %>%
  group_by(V4) %>%
  summarise(sumV2 = sum(V2))

# By several groups
DF %>%
  group_by(V4, V1) %>%
  summarise(sumV2 = sum(V2))


# Output grouped by V4
DF %>%
  group_by(tolower(V4)) %>%
  summarise(sumV1 = sum(V1))


# Assigning column name in by
DF %>%
  group_by(abc = tolower(V4)) %>%
  summarise(sumV1 = sum(V1))

# Using a condition in by
DF %>%
  group_by(V4 == "A") %>%
  summarise(sum(V1))

# Count number of observations for each group
DF %>%
  group_by(V4) %>%
  tally()

DF %>%
  group_by(V4) %>%
  summarise(n())
DF %>%
  group_by(V4) %>%
  group_size() # returns a vector

# Add a column with number of observations for each group
add_count(DF, V1)
DF %>%
  group_by(V1) %>%
  add_tally()
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table

DT[, .(sumV2 = sum(V2)), by = "V4"]
# one-liner:
# reordered and indented:
DT[, by = V4,
     .(sumV2 = sum(V2))]


# By several groups
DT[, keyby = .(V4, V1),
     .(sumV2 = sum(V2))]

# output grouped by V4
DT[, by = tolower(V4),
     .(sumV1 = sum(V1))]

# Assigning column name in by
DT[, keyby = .(abc = tolower(V4)),
     .(sumV1 = sum(V1))]

# Using a condition in by
DT[, keyby = V4 == "A",
     sum(V1)]

# Count number of observations for each group
DT[, .N, by = V4]
count(DF, V4)

# Add a column with number of observations for each group
DT[, n := .N, by = V1][]
DT[, n := NULL] # rm column for consistency

# Retrieve the first/last/nth observation for each group
DT[, data.table::first(V2), by = V4]
DT[, data.table::last(V2), by = V4]
DT[, V2[2], by = V4]
```

</div>
</div>
</div>


Going further
Advanced columns manipulation
To manipulate multiple columns, dplyr_1.0.0 has introduced the across() function, superseding the _all, _at, and _if versions of summarise(), mutate(), and transmute().
With data.table, we use .SD, which is a data.table containing the Subset of Data for each group, excluding the column(s) used in by. So, DT[, .SD] is DT itself and in the expression DT[, .SD, by = V4], .SD contains all the DT columns (except V4) for each values in V4 (see DT[, print(.SD), by = V4]). .SDcols allows to select the columns included in .SD.


<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles

#Summarise all the columns
DF %>% summarise(across(everything(), max))

# Summarise several columns
DF %>% summarise(across(c(V1, V2), mean))


# Summarise several columns by group
DF %>%
  group_by(V4) %>%
  summarise(across(c(V1, V2), mean))
# DF %>%
#   group_by(V4) %>%
#   summarise_at(c("V1", "V2"), mean)
DF %>%
  group_by(V4) %>%
  summarise(across(any_of(c("V1", "V2", "Z0")), mean))

# Summarise with more than one function by group
DF %>%
  group_by(V4) %>%
  summarise(across(everything(),
                   list(sum = sum, mean = mean)))
# columns named automatically
# DF %>%
#   group_by(V4) %>%
#   summarise_all(list(sum, mean))

# Summarise using a condition
DF %>%
  summarise(across(where(is.numeric),
                   mean))
# summarise_if(DF, is.numeric, mean)
DF %>% summarise(across(where(~ is.numeric(.x) && mean(.x) > 3), 
                        mean))
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table

#Summarise all the columns
DT[, lapply(.SD, max)]

# Summarise several columns
DT[, lapply(.SD, mean),
     .SDcols = c("V1", "V2")]

# Summarise several columns by group
DT[, by = V4,
     lapply(.SD, mean),
     .SDcols = c("V1", "V2")]
## using patterns (regex)
DT[, by = V4,
     lapply(.SD, mean),
     .SDcols = patterns("V1|V2|Z0")]


# Summarise with more than one function by group
DT[, by = V4,
     c(lapply(.SD, sum),
       lapply(.SD, mean))]


# Summarise using a condition
DT[, lapply(.SD, mean),
     .SDcols = is.numeric]
foo <- function(x) {is.numeric(x) && mean(x) > 3}
DT[, lapply(.SD, mean),
   .SDcols = foo]
```

</div>
</div>
</div>

#### Modify Multiples Varaibles

<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# Modify all the columns
DF %>%
  mutate(across(everything(),
                rev))


# Modify several columns (dropping the others)
DF %>% transmute(across(c(V1, V2),
                 sqrt))
# transmute_at(DF, c("V1", "V2"), sqrt)
DF %>% transmute(across(-any_of("V4"),
                 exp))
# transmute_at(DF, vars(-V4), exp)


# Modify several columns (keeping the others)
DF <- DF %>%
  mutate(across(all_of(c("V1", "V2")), sqrt))
# DF <- mutate_at(DF, c("V1", "V2"), sqrt)
DF <- DF %>%
  mutate(across(-any_of("V4"),
                 ~ "^"(.x, 2L)))
DF
# DF <- mutate_at(DF, vars(-V4), "^", 2L)


# Modify columns using a condition (dropping the others)
DF %>%
  transmute(across(where(is.numeric),
                   ~ '-'(., 1L)))
DF

DF <- DF %>%
  mutate(across(where(is.numeric),
         as.integer))


```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# Modify all the columns
DT[, lapply(.SD, rev)]


# Modify several columns (dropping the others)
DT[, lapply(.SD, sqrt),
     .SDcols = V1:V2]
DT[, lapply(.SD, exp),
     .SDcols = !"V4"]


# Modify several columns (keeping the others)
DT[, c("V1", "V2") := lapply(.SD, sqrt),
     .SDcols = c("V1", "V2")]

cols <- setdiff(names(DT), "V4")
DT[, (cols) := lapply(.SD, "^", 2L),
     .SDcols = cols]
DT

# Modify columns using a condition (dropping the others)
DT[, .SD - 1,
     .SDcols = is.numeric]
DT
DT[, (cols) := lapply(.SD, as.integer),
     .SDcols = is.numeric]
```

</div>
</div>
</div>

The use of DT[,j] is very flexible, allowing to pass complex expressions in a straightforward way, or combine expressions with multiple outputs.

#### More complex expression


<div class = "row">
<div class = "col-md-6">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R using Tibbles

DF %>%
  group_by(V4) %>%
  slice(1:2) %>%
  transmute(V1 = V1,
            V2 = "X")
```

</div>
</div>
<div class = "col-md-6">
<div class = "r">

```{r,echo=T,collapse = TRUE}
# R using data.table

DT[, by = V4,
     .(V1[1:2], "X")]

# Use multiple expressions (with DT[,{j}])
DT[, {print(V1) #  comments here!
      print(summary(V1))
      x <- V1 + sum(V2)
     .(A = 1:.N, B = x) # last list returned as a data.table
     }]
```

</div>
</div>
</div>


# Chain expressions
The dplyr workflow relies on the magrittr pipe operator (%>%). The magrittr package can also be used with data.table objects, but data.table comes with its own chaining system: DT[ ... ][ ... ][ ... ].

Expression chaining using DT[][] (recommended)
DT[, by = V4, 
     .(V1sum = sum(V1)) ][
     V1sum > 5]
DF %>%
  group_by(V4) %>%
  summarise(V1sum = sum(V1)) %>%
  filter(V1sum > 5)
Expression chaining using %>%
DT[, by = V4, 
     .(V1sum = sum(V1))] %>%
  .[order(-V1sum)]
DF %>%
  group_by(V4) %>%
  summarise(V1sum = sum(V1)) %>%
  arrange(desc(V1sum))

Indexing and Keys
Row subsetting in dplyr relies on the filter() and slice() functions, as shown in the first section. With data.table, in addition to the above-mentioned approach, two systems are available to make row filtering and join operations more convenient and blazingly fast (~170x speed-up): keys (primary ordered index) and indices (automatic secondary indexing).

The main differences between keys and indices are:
- When using keys, data are physically reordered in memory. When using indices, the order is stored as an attribute.
- Only one key is possible but several indices can coexist.
- Keys are defined explicitly. Indices can be created manually but are also created on-the-fly (and stored when using == or %in%).
- Indices are used with the on argument. It is optional when using keys, but recommended (and used below) for better readability.
Note: in the following code, we set both a key and an index to demonstrate their usage, but internally, indices are not used when a key already exists for the same columns(s).

Set the key/index
setkey(DT, V4)
setindex(DT, V4)
DT
DF <- arrange(DF, V4) # ordered just for consistency
DF
Select the matching rows
DT["A", on = "V4"]
DT[c("A", "C"), on = .(V4)] # same as on = "V4"
filter(DF, V4 == "A")
filter(DF, V4 %in% c("A", "C"))
Select the first matching row
DT["B", on = "V4", mult = "first"]
DT[c("B", "C"), on = "V4", mult = "first"]
DF %>%
  filter(V4 == "B") %>%
  slice(1)
# ?
Select the last matching row
DT["A", on = "V4", mult = "last"]
DF %>%
  filter(V4 == "A") %>%
  slice(n())
Nomatch argument
# (default) returns a row with "D" even if not found
DT[c("A", "D"), on = "V4", nomatch = NA]
# no rows for unmatched values
DT[c("A", "D"), on = "V4", nomatch = 0]
#
filter(DF, V4 %in% c("A", "D"))
Apply a function on the matching rows
DT[c("A", "C"), sum(V1), on = "V4"]
DF %>%
  filter(V4 %in% c("A", "C")) %>%
  summarise(sum(V1))
Modify values for matching rows
DT["A", V1 := 0, on = "V4"]
DT
DF <- DF %>%
  mutate(V1 = base::replace(V1, V4 == "A", 0L)) %>%
  arrange(V4)
DF
Use keys in by
DT[!"B", sum(V1), on = "V4", by = .EACHI]
DT[V4 != "B",
   by = V4,
   sum(V1)]   # same
DF %>%
  filter(V4 != "B") %>%
  group_by(V4) %>%
  summarise(sum(V1))
Set keys/indices for multiple columns
setkey(DT, V4, V1) # or setkeyv(DT, c("V4", "V1"))
setindex(DT, V4, V1) # setindexv(DT, c("V4", "V1"))
DT
DF <- arrange(DF, V4, V1) # ordered just for consistency
DF
Subset using multiple keys/indices
DT[.("C", 1), on = .(V4, V1)]
DT[.(c("B", "C"), 1), on = .(V4, V1)]
# using which = TRUE only returns the matching rows indices
DT[.(c("B", "C"), 1), on = .(V4, V1), which = TRUE]
filter(DF, V1 == 1, V4 == "C")
filter(DF, V1 == 1, V4 %in% c("B", "C"))
# ?
Remove keys/indices
setkey(DT, NULL)
setindex(DT, NULL)
DT
# 
DF

set*() modifications
In data.table, set*() functions modify objects by reference, making these operations fast and memory-efficient. In case this is not a desired behaviour, users can use copy(). The corresponding expressions in dplyr will be less memory-efficient.

Replace values
set(DT, i = 1L, j = 2L, value = 3L)
DT
DF[1, 2] <- 3L
DF
Reorder rows
setorder(DT, V4, -V1)
setorderv(DT, c("V4", "V1"), c(1, -1))
DF <- arrange(DF, V4, desc(V1))
Modify colnames
setnames(DT, old = "V2", new = "v2")
setnames(DT, old = -(c(1, 3)), new = "V2")
DT
DF <- rename(DF, v2 = V2)
DF <- rename(DF, V2 = v2) # reset upper
DF
Reorder columns
setcolorder(DT, c("V4", "V1", "V2"))
DT
DF <- select(DF, V4, V1, V2)
DF
Relocate columns
# coming soon (#4358)
DF %>%
  relocate(V4, .after = V2)
Convert data
# ?setDT # data.frame or list to data.table
# ?setDF # data.table to data.frame
# ?setattr # modify attributes
# 

Advanced use of by
Context dependent expressions (cur_*()) have been introduced in dplyr 1.0.0, reflecting data.table aliases .I, .GRP, …

Select first/last/… row by group
DT[, .SD[1], by = V4]
DT[, .SD[c(1, .N)], by = V4]
DT[, tail(.SD, 2), by = V4]
DF %>%
  group_by(V4) %>%
  slice(1)
DF %>%
  group_by(V4) %>%
  slice(1, n())
DF %>%
  group_by(V4) %>%
  group_map(~ tail(.x, 2))
Select rows using a nested query
DT[, .SD[which.min(V2)], by = V4]
DF %>%
  group_by(V4) %>%
  arrange(V2) %>%
  slice(1)
Add a group counter column
DT[, Grp := .GRP, by = .(V4, V1)][]
DT[, Grp := NULL] # delete for consistency
DF %>%
  group_by(V4, V1) %>%
  mutate(Grp = cur_group_id())
# DF %>% mutate(Grp = group_indices(., V4, V1))
Get row number of first (and last) observation by group
DT[, .I, by = V4] # returns a data.table
DT[, .I[1], by = V4]
DT[, .I[c(1, .N)], by = V4]
DF %>%
  group_by(V4) %>%
  mutate(cur_group_rows())
#DF %>%
#  group_by(V4) %>%
#  group_data() %>%
#  tidyr::unnest(.rows)
DF %>%
  group_by(V4) %>%
  summarize(cur_group_rows()[1])
DF %>%
  group_by(V4) %>%
  summarize(cur_group_rows()[c(1, n())])
# DF %>% group_by(V4) %>% group_rows() # returns a list
Handle list-columns by group
DT[, .(.(V1)),  by = V4]  # return V1 as a list
DT[, .(.(.SD)), by = V4] # subsets of the data
DF %>%
  group_by(V4) %>%
  summarise(list(V1))
DF %>%
  group_by(V4) %>%
  group_nest()
Grouping sets (multiple by at once)
rollup(DT,
       .(SumV2 = sum(V2)),
       by = c("V1", "V4"))

rollup(DT,
       .(SumV2 = sum(V2), .N),
       by = c("V1", "V4"),
       id = TRUE)

cube(DT,
     .(SumV2 = sum(V2), .N),
     by = c("V1", "V4"),
     id = TRUE)

groupingsets(DT,
             .(SumV2 = sum(V2), .N),
             by   = c("V1", "V4"),
             sets = list("V1", c("V1", "V4")),
             id   = TRUE)
#



# Pandas (Python)